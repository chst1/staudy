---
title: 计算机网络-自顶向下方法
date: 2019-12-18 21:45:11
tags: -计算机网络
categories: 操作系统
mathjax:
    true
description: 终于秋招上岸，怎奈何自己太菜，在去实习前被布置了一堆任务，其中就有我面试最怕的计算机网络。恰巧UNIX高级编程看到了套接字，发现没有计算机网络的知识直接看好像看不太明白，于是就把那个先放一放，等看完这本再回去接着看UNIX高级编程。当然，目前这个也在不断更新中。
---

<center/><font size = 12>计算机网络－自顶向下方法</font></center>
# 第一章　计算机网络和因特网

## 什么是因特网

因特网描述方式有两种：

1. 描述因特网具体构成：构成因特网的硬件和软件。
2. 分布式应用提供服务的网络基础设施。

### 具体构成描述

![组成](https://s2.ax1x.com/2019/12/13/QgUHg0.png)

主机（host）：与因特网相连的计算机等设备，也称为端系统（end system）。

端系统通过通信链路（communication link）和分组交换机（packet switch）连接到一起。

通信链路由不同类型的物理媒介组成，链路传播速度以bps度量。

分组：当一个端系统向另一个端系统发送时发送端系统将数据进行分段，并为每段加上首部字节，由此形成的信息包被称为分组，这些分组通过网络发送到目的端系统，在那里被装成初始数据。

分组交换机从它的一条入通信链路接收达到的分组，并从它的一条出通信链路转发该分组。当前最主要的两种分组交换机是路由器（router）和链路层交换机（link-layer switch）。

路径：从发送端到接收端，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径。

端系统通过因特网服务提供商（Internet Service Provider，ISP）接入因特网。每个ISP是一个由多个分组交换机和多段通信链路组成的网络。不同的ISP为端系统提供了各种不同类型的网络接入（各种调制解调器、高速局域网接入和无线接入）。底层ISP通过高层ISP互联。每个ISP独立管理，运行IP协议。

端系统、分组交换机和其他因特网部件都要运行控制中接收和发送信息的一系列协议。TCP（Transmission Control Protocol，传输控制协议）和IP（Internet Protocol，网际协议）是因特网中最重要的两个协议。IP协议定义了在路由器和端系统中发送和接受的分组的格式。因特网主要协议统称为TCP/IP。

公共因特网：特定网络，因特网。网络的网络，即将网络连接起来的网络。

内联网：专用网络，这些网络内的主机不能与专用网络外部的主机交换信息（除非这些信息通过了所谓的防火墙，否则防火墙一般会限制报文进入和流出网络）。

### 服务描述

分布式应用程序：涉及多台相互交换数据的端系统的程序。因特网应用程序运行在端系统上，即它们并不在网路核心的分组交换机上。

与因特网相连的端系统提供了一个应用编程接口（Application Programming Interface，API），API规定了运行在一个端系统上的软件请求因特网基础设施向另一个端系统上的特定目的地软件交付数据的方式。因特网是一种基础设施，新应用程序正在其上不断地被发明和设置。

### 什么是协议

网路协议类似于人类协议，不过交换报文和采取行动的是某些设备的硬件或软件组件。因特网的所有活动，凡是涉及两个或多个通信的远程实体都受协议限制。

一个协议定义了两个或多个通信实体之间交换的报文格式和次序，以及在报文传输或接收或其他事件方面所采取的动作。

## 网络边缘

端系统位于网络的边缘。端系统包括桌面计算机、服务器和移动计算机，还包括越来越多的其他类型设备。主机=端系统。主机又被分为客户机和服务器。

### 客户机和服务器程序

客户程序运行在一个端系统上，它发出请求，并从运行在另一个端系统的服务器程序接收服务。客户机-服务器应用程序是分布式应用程序，客户机和服务器通过因特网护发报文以交互。

对等（P2P）应用程序：用户端程序起着客户机程序和服务器程序的双重作用。当它向一个对等方请求文件时，起着客户机的作用，向另一个对等方发送文件时起着服务器的作用。

### 接入网

接入网：端系统连接到其边缘路由器的物理链路。边缘路由器是端系统到任何其他远程端系统的路径上第一个路由器。

住宅接入：拨号调制解调器。

公司接入：局域网（LAN）。

无线接入：无线局域网（wireless LAN），广域无线网（wide-area wireless access network）。

### 物理媒介

导引型媒体：电波沿着固体媒体被传导：

1. 双绞铜线
2. 同轴电缆
3. 光钎

非导引型媒体：电波在空气或外层空间中传播：

1. 陆地无线电信道
2. 卫星无线电信道

## 网络核心

网路核心：因特网端系统的分组交换机和链路的网状结构。

### 电路交换和分组交换

通过网络链路和交换机移动数据有两种基本方法：电路交换和分组交换。

电路交换中，沿着端系统通信路径，为端系统之间通信所提供的资源（缓存、链路传输速率）在通信会话期间会被预留。代表为电话网络。

分组交换网络中，这些资源不会被预留；会话的报文按需使用这些资源，这将导致可能不得不等待（排队）接入通信线路。代表为互联网。

#### 电路交换网络中的多路复用

链路中的网络要实现多路复用（使得一条线路可以有多条连接）有两种方式：

1. 频分多路复用（Frequency-Division Multiplexing，FDM）：链路的频谱由跨越链路创建的所有连接所共享。特别是，该链路在连续期间为每条连接专用一个频段。在电话网络中，这个频段通常是4kHz，该频段被称为带宽。调频无线电台也使用FDM来共享88~108MHZ的频谱，其中为每一个电台被分配一个特定的频带。
2. 时分多路复用（Time-Division Multiplexing，TDM）：时间被划分为固定区间的帧，每帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，该网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙可用于传输该连接（在每个帧内）的数据。

电路交换缺点：

1. 效率低，因为在静默期专用电路空闲，不能被其他进行中的连接所使用。
2. 创建端到端电路和预留端到端带宽是很复杂的，需要复杂的信令软件来协调沿端到端路径的交换机的操作。

#### 分组交换

源主机将长报文划分为较小的数据块，并称之为分组。在源和目的之间，这些分组中的每个都通过通信链路的分组交换机（路由器和链路层交换机）传送。

**存储转发机制**（store-and-forward transmission）：交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。因此，存储转发式分组交换机沿着该分组的路径在每条链路的输入端引入存储转发时延。

**输出缓存**（output buffer）（也称输出队列（output queue））：每个分组交换机有多条链路与之相连，对于每一条相连的链路，该分组交换机具有一个输出缓存，它用于存储路由器准备发往那条链路的分组。如果到达的分组需要跨越链路传输，但发现该链路忙于其他分组，该到达分组必须在输出缓存中等待。因此除了存储转发时延以外，分组还要承受输出缓存的**排队时延**（queue delay）。由于缓存区大小有限，因此一个到达的分组可能发现该缓存被等待传输的分组完全占满了，此时将出现**分组丢失**或**丢包**（packet lost）——可能是到达的该分组也可能是已经排队的分组之一将被丢弃。

![store-and-forward](https://s2.ax1x.com/2019/12/13/QgvUYT.png)

分组交换的缺点：其端到端时延是变动的和不可预测的（主要是因为排队时延的变动和不可预测），因此不适合实时服务（如电话）。

分组交换的优点：

1. 提供了比电路交换更好的带宽。
2. 以电路交换更简单、更有效，实现成本更低。

统计多路复用：按需共享资源。

### 分组如何通过分组交换形成其通路

在因特网中，每个通过该网络传输的分组在它的首部包含了其目的地地址，该地址是一种层次结构。当分组到达网络中的一台路由器时，该路由器检查分组的目的地地址的一部分，并向相邻路由器转发该分组。更特别的，每台路由器具有一个转发表，用于将目的地地址（或其中一部分）映射到输出链路。当分组到达一台路由器时，该路由器检查目的的地址，并用这个目的的地址搜索转发表，以找到合适的输出链路。然后路由器将该分组导向输出链路。

### ISP和因特网主干道

第一层ISP的特性：

1. 直接与其他每个第一层ISP相连。
2. 与大量的第二层ISP和其他客户网络相连。
3. 覆盖国际区域。

第一层ISP也被称为因特网主干道。第二层ISP通常具有区域性或国家线覆盖规模，并且非常重要的只与少数第一层ISP相连接。第二层ISP需要引导流量通过它所连接的第一层ISP。第二层ISP被他所连接的第一层ISP称为客户，第一层ISP是第二层ISP的供应商。第二层之下是较低层ISP，层次结构的底层是接入ISP。当两个ISP直接相连时，他们被称为是对等的。

一个ISP网络中，某ISP与其他ISP的连接点被称为汇集点（Point of Presence，POP）。POP就是某ISP中的一台或多台路由器组，通过他们能够与其他ISP的路由器连接。

## 分组交换网中的时延、丢包和吞吐量

### 时延概述

分组从一个节点（主机或路由器）沿着路径到后继节点（主机或路由器）时，该节点在沿途的每个节点都经受了几种不同的时延。主要包括：**节点处理时延**（nodal processing delay）、**排队时延**（queuing delay）、**传输时延**（Transmission delay）和**传播时延**（propagation delay），这些时延总体累加起来是**节点总时延**（total delay）。

![delay](https://s2.ax1x.com/2019/12/13/Q2pA9f.png)

处理时延：检测分组首部和决定将该分组导向何处所需时间是处理时延的主要部分。一般处理时延较短（微秒级或者更低）。

排队时延：在队列中，当分组在链路上等待传输时，经受排队时延。队列很空且没有其他分组在传输时，排队时延是0。流量很大时，排队时延就会比较大。实际排队时延在毫秒到微秒级。

传输时延：仅当分组的整体全部导到时，才能传输我们的分组。L表示分组的比特长度，R bps表示从路由器A到路由器B的传输速率。传输时延是L/R，即将所以比特推（传输）向链路所需要的时间。实际传输时延在好秒到微妙级。

传播时延：从该链路的起点到路由器B传播所需要的时间是传播时延。比特以该链路的传播速率传播。其速率范围是2\*10^8 ~ 3*10^8，传播时延等于路由器间的距离除以传播速度。

传输时延是路由器将分组推出所需要的时间，它是分组长度和链路传输速度的函数，而于传输距离无关。传播时延是一个比特从一台路由器向另一台路由器传播所需要的时间，是距离的函数，与分组长度或链路的传输速度无关。
$$
d_{nodal} = d_{proc}+d_{queue}+d_{trans}+d_{prop}
$$

### 排队时延和丢包

节点时延最复杂的就是排队时延。其取决于流量到达该队列的速率、链路的传输速率和流量到达性质。

**流量强度**：令a表示分组到达的平均速率（a的单位是每秒分组，即packet/s）；R是传输速率，即比特从队列中推出的速率，单位是bps；为了简化起见，假定所以分组是由L比特组成的，则比特到达队列的平均速率是La bps。此时La/R被称为流量强度。

如果流量强度大于1，则比特到达队列的平均速度超过该队列传输出去的速度，此时队列的增加趋于无界，且排队时延无限大。当流量强度小于1时，到达流量的性质影响排队时延，如果分组以突发形式到达而不是周期形式到达，则可能有很大的平均排队时延。

丢包的数量随着流量强度的增加而增加。

### 端到端时延

Traceroute程序：其能够在任何因特网主机上运行。当用户指定一个目的主机名字时，源主机中的该程序朝着该目的地发送多个特殊的分组（默认30个）。当这些分组向着目的地传送时，他们通过一系列路由器。当路由器接收到这些特殊分组时，它向源回送一个短报文，该报文包括路由器名字和地址。

处理流程：假定在源与目的地之间有N-1台路由器，则源将向网络发送N个特殊的分组，其中每个分组地址指向最终的目的地。这N个特殊分组标识从1到N，第一个分组标识为1，最后的分组标识为N。当第n台路由器接收到第n个标识为n的分组时，该路由器不是向目的地转发，而是向源回送一个报文。当目的的主机接到第N个分组时，也会向源返回一个报文。该源记录了从它发送一个分组到它接收到对应返回报文所经受时间，也记录了返回该报文的路由器（或目的地主机）的名字和地址。以这种方式，源能够重建分组从源到目的地所采用的路由，并且能够获得到所有中间路由器的往返时延。Traceroute实际上对上述实验重复了三次，因此实际发送了3*N组数据。

traceroute输出有6列：第一列是前面描述的n值，即沿着路径上的路由器号码；第二列是路由器名字；第三列是路由器地址；最后三列是3次往返时延。如果源从任何给定的路由器接收少于三条报文（由于网络中丢包），则traceroute在该路由器号码后面放一个星号，并向那台路由器报告少于3次往返时间。例如：

```
$ traceroute www.yinkuiwang.cn
traceroute to www.yinkuiwang.cn (185.199.110.153), 30 hops max, 60 byte packets
 1  _gateway (10.136.0.1)  2.857 ms  3.053 ms  3.157 ms
 2  202.113.18.229 (202.113.18.229)  3.281 ms  3.390 ms  3.742 ms
 3  202.113.18.102 (202.113.18.102)  2.748 ms  3.839 ms  3.804 ms
 4  111.33.78.1 (111.33.78.1)  4.961 ms  4.929 ms  5.200 ms
 5  117.131.131.13 (117.131.131.13)  4.239 ms  4.442 ms 117.131.131.9 (117.131.131.9)  4.587 ms
 6  221.183.38.49 (221.183.38.49)  5.822 ms  2.652 ms  2.647 ms
 7  * 221.183.8.150 (221.183.8.150)  15.551 ms *
 8  221.176.21.146 (221.176.21.146)  10.094 ms  10.091 ms 221.176.21.186 (221.176.21.186)  25.060 ms
 9  221.183.46.253 (221.183.46.253)  16.063 ms  16.178 ms *
10  221.183.30.234 (221.183.30.234)  207.610 ms 221.183.30.230 (221.183.30.230)  198.938 ms 221.183.30.246 (221.183.30.246)  195.548 ms
11  223.120.6.97 (223.120.6.97)  252.070 ms * 223.118.12.5 (223.118.12.5)  218.268 ms
12  223.120.6.113 (223.120.6.113)  239.274 ms 223.120.6.26 (223.120.6.26)  237.843 ms *
13  * * *
14  lag-10.ear1.Madrid2.Level3.net (4.68.111.45)  238.222 ms  236.624 ms  243.475 ms
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *
```

由于排队时延随时间变化，所以分组n发送到路由器n的往返时延可能大于分组n+1发送到路由器n+1的往返时延。比如上面2和3的第一个时延。

### 计算机网络中的吞吐量

瞬时吞吐量：从主机A向主机B传输一个大文件，B接收该文件的速率（单位bps）。

平均吞吐量：该文件由F比特组成，而主机B接收到所以F比特使用了T秒，则平均吞吐量为F/T bps。

从端系统到另一个端系统的吞吐量取决于拼劲链路，即路径中链路速度最慢的那个链路。

## 协议层次和它们的服务模型

### 分层的体系结构

网络设计者以分层的方式组织协议以及实现这些协议的网络硬件和软件。每个协议属于一层，某层向其上一层提供服务（service），即所谓的层的服务模型，某层通过在该层中执行某些动作或者使用其直接下层的服务来提供它的服务。

一个协议层能够通过软件和硬件或两者的结合实现。应用层在端系统的软件中实现，运输层也是这样。物理层和链路层负责处理跨特定链路的通信，通常在与给定链路相关的网络接口卡中实现。网络层经常是软件和硬件的结合。层n协议的不同部分常常位于这些网络组件的各部分。

协议分层的优点是：概念化结构化；模块化使得更新系统组件更加容易。

缺点：某层可能重复其较低层的功能；某层的功能可能需要仅在其他某层才出现的信息，这违反了层次分离的目标。

![分层](https://s2.ax1x.com/2019/12/14/Q2bQvn.png)

**应用层**

应用层是网络应用程序及其应用层协议存留的地方。应用层包含很多协议：HTTP（web文档请求和传送）；SMTP（电子邮件报文传输）；FTP（两个端系统之间文件传送）。还有某些网络功能，如DNS（域名系统）将网址转换为32比特网络地址。

应用层协议分别在多个端系统中，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。位于应用层的信息分组称为报文（message）。

**运输层**

运输层提供了在应用程序端点之间传送应用层报文的服务。因特网存在两个运输协议TCP和UDP。TCP向它的应用程序提供了面向连接的服务，这种服务包括了应用层报文向目的地的确保确保传递和流量控制。TCP将长报文换分为短报文，并提供阻塞控制机制，当网络阻塞时，源抑制其传输速率。UDP协议提供无连接服务，其不提供不必要的服务，不提供可靠性，没有流量控制，也没有拥塞控制。运输层分组称为报文段（segment）。

**网络层**

网络层负责将数据报的网络层分组从一台主机移动到另一台主机源主机的因特网运输层协议向网络层递交运输层报文段和目的地地址。

因特网网络层包括著名的IP协议，该协议定义了数据中各个字段以及端系统和路由器如何作用于这些字段。所有网络层的因特网组件都必须运行IP协议。因特网的网络层也包含决定路由的选路协议。IP是将因特网连接在一起的粘合剂。

**链路层**

为了将分组从一个节点移动到路径的下一个节点，网络层必须使用链路层服务。在每一个节点，网络层将数据报下传给链路层，链路层沿着路径将数据传输给下一个节点，在下一个节点，链路层将数据报上传给网络层。

链路层提供的服务取决于应用于该链路的特定链路协议。主要有以太网、WIFI和点对点协议（PPP）。链路层分组称为帧。

**物理层**

链路层是将帧从一个网路元素移动到临近的网络元素。物理层任务是将该帧中的一个一个比特从一个节点移动到下一个节点。

**ISO**模型

ISO多加了两层，表示层和会话层。表示层是使通信的应用程序能够解释交换数据的含义，提供的服务包括数据压缩、数据加密以及数据描述。会话层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案的方法。

### 报文、报文段、数据报和帧

![传输](https://s2.ax1x.com/2019/12/14/Q2LEtS.png)

上图显示了一条物理路径：数据从发送端系统的协议向下，上下中间的链路层交换机和路由器的协议栈，进而向上到达接收端系统的协议栈。

上图也说明了封装这一重要概念。在发送主机，应用层报文（M）被传送给运输层；运输层收取报文并附上附加信息（运输层首部Ht），该首部将被被接收的运输层使用。应用层报文和运输层首部信息共同构成了运输层报文段。运输层报文段因此封装了应用层报文。运输层则向网络层传递该报文段，网络层增加了如源和目的地端系统地址等网络首部信息形成网络层数据报。该数据报接下来被传递给链路层，链路层添加自己的链路首部信息并创建链路帧。于是，在每一层，分组具有两种类型的字段：首部字段和有效荷载字段，有效荷载字段来自于上一层。

## 攻击威胁下的网络

### 坏家伙能够经因特网将恶意软件放入你的计算机

僵尸网络：被恶意软件感染的设备，受害主机还能征招网络上数以千计的类似受害设备。

自我复制：一旦恶意软件感染了一台主机，就会从那台主机进入到更多主机。

病毒：一种需要某种形式的用户交互来感染用户设备的恶意软件。

特洛伊木马：隐藏在有用软件的恶意软件。

### 坏家伙能够攻击服务器和网络基础设施

拒绝服务攻击（Denial-of-Service，DoS）是一种宽泛的安全性攻击，其使得合法用户不能使用网络、主机或其他基础设施部分。DoS攻击主要分为三种：

1. 弱点攻击：向目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文。如果多个分组以适当的顺序发送给一个易受攻击的应用程序或操作系统，该服务可能停止运行，甚至导致主机奔溃。
2. 带宽泛洪：攻击者向目标主机发送大量的分组，导致目标的接入链路变得拥塞，从而使合法的分组无法到达服务器。
3. 连接泛洪：攻击者在目标主机中创建大量的半开或全开TCP连接。目标主机因这些伪造的连接而显然困境，从而停止合法的连接。

对于带宽泛洪，单一源可能无法产生足够大的流量来危害服务器，同时单一攻击可能被上游路由器检测出该攻击并在该流量靠近服务器前就将其阻挡下来。分布式DoS（distributed Dos，DDos）中，攻击者控制多个源并让每个源向目标猛烈发送流量。

### 坏家伙能嗅探分组

在无线传输设备的附加放置一台被动接收机，该接收机就能得到传输的每个分组的拷贝。记录每个流经分组拷贝的被动接收机被称为分组嗅探器。

嗅探器也可用于有线环境，如在有线广播中。嗅探器是被动接收设备，很难被发现，因此最后的防御手段是密码学方式。

### 坏家伙能够伪装成你信任的人

生成具有任意原地址、分组内容和目的地址的分组，然后将这个人工制作的分组传输到因特网中是十分容易的。将虚假源地址的分组注入因特网的能力被称为IP哄骗（IP spoofing），这只是一个用户能够冒充另一个用户的多种形式之一。

为解决这个问题，需要采用端点鉴别（end-point authentication）机制，即确保报文源自我们认为应该来自的地方的机制。

### 坏家伙能够修改或删除报文

坏家伙插入到两个通信实体之间，危及发送信息的完整性。

# 第二章 应用层

## 应用层协议原理

### 网络应用程序体系结构

从应用程序研发者角度来看，网络体系结构是固定的，并为应用程序提供了特定的服务集合。现代网络应用程序所使用的两种主流体系结构：客户机/服务器体系结构或对等（P2P）体系结构。

在客户机/服务器体系结构中，有一个总是打开的主机被称为服务器，它服务来自许多客户机的主机请求。典型例子为Web应用程序。在这个结构中，客户机之间不直接相互通信，服务器有固定的、周知的地址，称为IP地址。

在P2P体系结构中，对总是打开的基础设施服务器有最小的（或者没有）依赖。任意间断连接的主机对——称为对等方，直接通信。P2P协议最突出的特性之一是它的自扩展性。

某些应用具有混合的体系结构，由客户机/服务器和P2P元素结合而成，往往服务器场用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间直接发送。

### 进程通信

网络应用程序是由成对的进程组成，这些进程通过网络相互发送报文。在给定的一对进程中之间的通信会话中，发起通信（即在该回话开始时与其他进程联系）的进程被标示为客户机，在会话开始时等待联系的进程是服务器。

进程通过套接字软件接口在网络上发送和接收报文。应用程序开发者可以控制套接字在应用层端的所以东西，但是对套接字的运输层端几乎没有控制。应用程序开发者对于应用层端的控制仅限于：

1. 选择运输协议。
2. 设定部分运输层参数，如最大缓存、最大报文长度等。

### 可供应用程序使用的传输协议

**可靠传输数据**

第一章讨论过，分组可能会存在丢包，部分程序要保证数据完整性。如果一个协议提供了确保数据交付服务，就提供了**可靠数据传输**。运输层协议能够潜在的向应用程序提供的一个重要服务是进程到进程的可靠数据传输。此时，发送进程只要将数据传递给套接字，就可以相信数据被无差错到达接收进程。

部分程序运行存在部分丢包，即为容忍丢失的应用。

**吞吐量**

具有吞吐量要求的应用程序，被称为带宽敏感应用。弹性应用根据需要充分利用可供使用的吞吐量。

**定时**

部分应用为了有效性而对数据交付有严格的时间限制。

**安全性**

运输层协议能够为应用程序提供一种或多种安全性服务。

### 因特网的运输服务

因特网（TCP/IP网络）上的应用使用了两个运输层协议：UDP和TCP。创建应用时首先要决定使用哪一个。

#### TCP服务

TCP服务模型包括面向连接服务和可靠数据传输服务。

（1）面向连接服务：使用TCP协议时，在应用层数据报文开始流动之前，其客户机程序和服务器程序之间互相交换运输层控制信息。即为握手过程，此过程提示客户机和服务器之间建立了一个**TCP连接**。这个连接是双全工的，即两个进程可以同时进行报文的收发。当应用程序结束报文发送时，必须拆除该连接。

（2）可靠数据服务：进程通信的进程依靠TCP协议，无差错、按适当顺序交付发送的数据。没有子节的丢失和冗余。

（3）拥塞控制机制：这种机制不为通信进程带来直接好处。但能够为因特网带来整体好处。当发送方和接收方之间网络发生拥塞时，TCP协议的拥塞控制机制会抑制发送进程。此机制对带宽敏感的应用有害。

#### UDP服务

UDP是一种不提供不必要服务的轻量级运输层协议，它仅提供最小服务。UDP是无连接的，因此两个进程之间没有握手的过程。UDP协议提供的是不可靠数据传输服务，即不保证一定能收到，也不保证顺序。

UDP没有拥塞控制机制。

#### 因特网运输层不提供的服务

目前因特网不提供吞吐量和定时的保证。下面列出了一些流行因特网应用使用的运输层协议：

| 应用         | 应用层协议                | 运输层协议 |
| ------------ | ------------------------- | ---------- |
| 电子邮件     | SMTP                      | TCP        |
| 远程终端访问 | Telnet                    | TCP        |
| Web          | HTTP                      | TCP        |
| 文件传输     | FTP                       | TCP        |
| 流媒体       | HTTP、RTP                 | TCP或UDP   |
| 因特网电话   | SIP、RTP或专用（如Skype） | 通常用UDP  |

#### 进程寻址

为了识别接收进程，需要定义两种信息：（1）该主机的名称或地址，（2）用来指定目的主机上接收进程的标识。

在因特网中，主机使用IP地址进行标识（第四章深入探究）。此时，我们只要知道IP地址是用来**唯一**标识主机的32比特数就足够了。

发送程序也必须识别运行在主机上的接收进程，目的地端口服务于此目的。已经给流行的应用程序分配了特定的端口号。如Web是80号。这是为了特定应用程序开发时大家统一，可以直接进行通信。

### 应用层协议

应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。其主要定义了如下内容：

1. 交换的报文类型，如请求报文和响应报文。
2. 各种类型的语法，如报文中的各个字段及其详细描述。
3. 字段的语义，即包含在字段中的信息含义。
4. 进程何时、如何发送报文以及对报文响应的规则。

网络应用和应用层协议的区别：应用层协议只是网络应用的一部分，只是定义了应用程序之间沟通的协议。

## Web应用与HTTP协议

### HTTP概况

Web应用层协议是超文本传输协议（HyperText Transfer Protocol，HTTP）。HTTP协议有两部分程序实现：客户机程序和服务器程序，它们运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的格式以及客户机和服务器是如何进行报文交换的。

Web页面（Web page，也叫文档）是由对象组成的。对象简单来说就是文件，如HTML文件，JPEG图片文件、Java小程序或视频文件，这些文件可以通过一个URL地址寻址。多数Web页面含义一个基本的HTML文件以及几个引用对象。如一个Web页面包括一个HTML文件和5个JPEG图形文件，那这个Web页面有六个对象。每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。如：`http://www.someschool.edu/someDepartment/picture.gif`中的`www.someschool.edu`即为主机名，`/someDepartment/picture.gif`即为路径。

HTTP定义了Web客户端如何向Web服务器请求Web页面，以及服务器如何将Web页面传送给客户端。

HTTP使用TCP作为支撑运输层协议。HTTP客户机发送一个与服务器的TCP连接，建立连接后，客户端和服务器就可以进行通信了。

服务器向客户机发送请求的文件时，并不存储任何关于该客户机的状态信息。由于HTTP服务器不存储关于客户机状态的信息，使用说HTTP是一个无状态协议。

### 非持久连接和持久连接

当客户机/服务器的交互运行于TCP之上时，应用程序开发者需要确定每个请求/响应是经过单独的TCP连接发送还是所以请求及响应经相同的TCP连接发送。前者称为非持久连接，后者称为持久连接。HTTP两者都支持，默认使用持久连接。非持久连接每个TCP连接只传输一个请求报文和一个响应报文。

**往返时间**（Round-Trip Time，RTT）：即一个小分组从客户机到服务器再回到客户机所花费的时间。一个RTT等于三次握手中前两个部分所消耗的时间。

非持久连接缺点：

1. 必须为每一个请求的对象建立和维护一个全新的连接，对于每个这样的连接，在客户机和服务器都要分配TCP的缓冲区和变量，这给服务器带来严重负载。
2. 每个对象的传输时延为两个RTT（三次握手前两部分为一个，第三次握手（确认）同时发送请求，因此只有两个RTT）。

### HTTP报文格式

HTTP有两种报文：请求报文和响应报文

#### 请求报文

下面是一个典型的请求报文：

```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/4.0
Accept-language: fr
```

HTTP请求第一行叫做请求行，其后继的行叫做首部行。请求行有三个字段：方法字段、URL字段和HTTP协议版本字段。方法字段可以取值GET、POST、HEAD、PUT和DELETE。

首部行`Host:www.someschool.edu`定义了目标所在主机。`Connection:close`首部行，告诉服务器不希望麻烦的使用持久连接，要求服务器发送完请求的对象后就关闭连接。`User-agent:`首部行用来定义用户代理，即向服务器发送请求的浏览器类型。`Accept-language`表示用户想要得到该对象的语法版本。`Accept-language:`是可选内容协商首部之一。

下图展示了请求报文的通用格式：

![http requer](https://s2.ax1x.com/2019/12/17/Qox10K.png)

在首部行和附加回车换行后有一个实体主体（Entity body）。使用GET方法时实体主体为空，使用POST方法时才使用。使用POST方法的报文中，用户依然可以请求一个Web页面，但Web返回的内容依赖于POST方法的报文中。当方法字段值为POST时，实体主题中包含的就是用户在表单字段中输入的内容。

HTML表单经常使用GET将输入数据（在表单字段中）传送到正确的URL。如，一个表单使用GET方式，它有两个字段，分别填写的是monkey和bananas，那么得到的URL结构为：`www.somesite.com/animalsearch?monkey&bananas`。

HEAD方法类似于GET。当服务器收到使用HEAD方法的请求时，会用一个HTTP的报文进行响应，但是并不返回请求对象（用于调试）。PUT方法用来向Web服务器上传对象。DELETE方法，用来删除Web服务器上的对象。

#### HTTP响应报文

典型响应报文格式：

```
HTTP/1.1 200 OK
Connection: close
Date: THu,03 Jul 2003 12:00:15 GMT
Server: Apache/1.3.0(Unix)
Last-Modified: Sun,6 May 2007 09:23:24 GMT
Connect-Length: 6821
Content-Type: text/html

(data data ...)
```

响应分三部分：一个初始状态行，首部行和实体主体。实体主体是报文的主体，它包含一个所请求对象本身。状态行有三个字段：协议版本、状态码和相应状态信息。

`Connection:close`首部行告诉客户机发送完毕后关闭连接。`Date`首部行指示服务器产生并发送该响应报文的日期和时间。时间是指服务器从它的文件系统中检索到该对象，插入到响应报文的时间。`Server`报文指示服务器类型，类似与请求报文中`User-agent`首部行。`Last_Modified`首部行指示了对象穿件或最后修改的日期和时间。`Content_Length`表明被发送对象的字节数。`Content_Type`指示了实体主体原本的类型（HTML还是图片等）。

下图展示了响应报文的通用格式：

![http return](https://s2.ax1x.com/2019/12/17/Qox3TO.png)

一些常见的状态码：

| 200  | OK                         | 请求成功                                                     |
| ---- | -------------------------- | ------------------------------------------------------------ |
| 301  | Moved Permanently          | 请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户机软件自动用新的URL获取该对象。 |
| 400  | Bad REquest                | 一个通过错误代码，指示请求不能被服务器理解。                 |
| 404  | NOT Found                  | 请求的文档不在服务器上。                                     |
| 505  | HTTP version not supported | 服务器不支持请求报文使用的HTTP协议版本。                     |

可以使用`telnet`来观察真实的HTTP响应报文。使用`telnet site 80`即建立了一个本地到指定Web服务器的TCP连接，之后输入请求即可，如下：

```
$ telnet www.yinkuiwang.cn 80
Trying 185.199.111.153...
Connected to chst1.github.io.
Escape character is '^]'.
GET /2019/06/16/KMP/ HTTP/1.1
Host:www.yinkuiwang.cn

HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Server: GitHub.com
Last-Modified: Mon, 02 Dec 2019 08:16:22 GMT
ETag: "5de4c856-67bd"
Access-Control-Allow-Origin: *
Expires: Wed, 18 Dec 2019 01:39:45 GMT
Cache-Control: max-age=600
X-Proxy-Cache: MISS
X-GitHub-Request-Id: B9A8:56A3:1F39F4:214343:5DF98109
Content-Length: 26557
Accept-Ranges: bytes
Date: Wed, 18 Dec 2019 01:29:45 GMT
Via: 1.1 varnish
Age: 0
Connection: keep-alive
X-Served-By: cache-hnd18746-HND
X-Cache: MISS
X-Cache-Hits: 0
X-Timer: S1576632586.764452,VS0,VE186
Vary: Accept-Encoding
X-Fastly-Request-ID: cf573b3feb014acb04fd481fecf2de696fde337e

<!DOCTYPE html>
```

后面的实体主体没有全部展示。注意，在敲下Host首部行之后要连击两下回车，表示输入请求完成。

### 用于与服务器的交互：cookie

前面提到，HTTP是无状态的，然而一个Web站点通常希望能够识别用户，即可能是为了服务器限制用户访问，也可能是它想把内容与用户身份联系起来。为此，HTTP使用了cookie，它允许站点跟踪用户。

![cookie](https://s2.ax1x.com/2019/12/18/QT2s6s.png)

如上图所示，cookie由四部分组成：

1. 在HTTP响应报文中有一个cookie首部行；
2. 在HTTP请求报文中有一个cookie首部行；
3. 在用户端系统保留一个cookie文件，由用户的浏览器管理；
4. 在Web站点有一个后端数据库。

cookie可以在无状态的HTTP上建立一个用户层会话。例如，基于Web的电子邮件系统，浏览器向服务器发送一个cookie信息，运行该服务器通过用户与应用程序之间的会话对用户进行验证。

### Web缓存

Web缓存器（Web cache）也叫代理服务器（proxy server），它是能够初始Web服务器来满足HTTP请求的网络实体。Web缓冲器有自己的磁盘存储空间，并在该存储空间中保存最近请求的对象的拷贝。

![web cache](https://s2.ax1x.com/2019/12/18/QTWdzQ.png)

一旦配置了浏览器，每个浏览器对对象的请求首先被定向到Web缓存器。其请求所经历流程大致如下：

1. 浏览器建立一个到Web缓存器的TCP连接，并发送请求。
2. Web缓存器检测本地是否存储了该对象的拷贝。如果有，Web缓存器就用HTTP响应报文回复。
3. 如果Web缓存器没有该对象，它就与该对象的初始服务器打开一个TCP连接，并发送请求。
4. 当Web缓存器接收到该对象时，在本地存储一份拷贝，并用HTTP响应报文向客户端发送报文。

Web缓存器的好处：

1. 大大减少客户机请求响应时间，尤其在客户机与初始服务器之间的瓶颈带宽远低于客户机与Web服务器瓶颈带宽时。
2. 可以大大减少一个机构内部网与因特网接入链路上的通信量，降低费用。
3. 整体上大大降低因特网上的Web流量，从而改善所有应用的性能。

### 条件GET方法

条件GET方法是一种机制，允许缓存器证实它的对象是最新的。如果（1）请求报文使用GET方法；（2）请求报文包含一个`if-modified-since`首部行，那么这个HTTP请求报文就是一个条件GET请求报文。

缓存器发送一个条件GET，执行最新检查，例如：

```
GET /fruit/kiwi.gif HTTP/1.1
Host: www.somesite.com
If-modified-since: Wed,4 Jul 2007 09:23:24
```

该条件GET报文告诉服务器，仅当自指定日期之后修改过该对象才发送该对象。如果未改动过该对象，初始服务器响应报文可能是：

```
HTTP/1.1 304 Not Modified
Date: Sat,14 Jul 2007 15:39:29
Server: Apache/1.3.0(Unix)
(实体主体为空)
```

## 文件传输协议：FTP

![FTP](https://s2.ax1x.com/2019/12/18/QT7TPI.png)

FTP用于向一台远程主机上传或下载其文件。为了使用户能够访问远程主机，用户必须提供一个用户标识和口令。

HTTP和FTP都是文件传输协议，存在很多异同。相同点都是使用TCP作为运输层协议。主要区别是FTP使用两个并行的TCP连接来传输文件，一个是控制连接，一个是数据连接。控制连接用于在两个主机之间传输控制信息，如用户标识、口令、改变远程目录的命令以及“put”和“get”命令。数据连接用于实际传输一个文件。FTP使用一个分离的控制连接，所以我们称其控制信息是**外带**传送的。HTTP是**内带**的。

下图展示了FTP控制连接和数据连接：

![FTP](https://s2.ax1x.com/2019/12/18/QTqQbD.png)

当用户主机与远程主机开始一个会话前，FTP的客户机首先在21号端口上发起一个用于控制的与服务器的TCP连接。FTP客户机通过该控制连接发送用户标识与口令，也改变远程目录的命令。当FTP服务器端从该连接上收到一个文件传输的目录后，就发起一个客户端的数据连接。FTP在该连接上准确地传送一个文件并关闭该连接。如果还要传输别的文件，FTP则另打开一个连接。FTP控制连接贯彻了整个用户会话期间，但文件传输连接只在每次需要时才建立。

FTP服务器必须在整个会话期间保存用户的状态。服务器必须把特定用户账户与控制连接联系起来，随着用户在远程目录树上移动，服务器必须追踪用户在目录树上的当前位置。而HTTP是无状态的，不必对用户行为进行追踪。

一些常用FTP命令有：

USER username：用于向服务器传送用户标识。

PASS password：用于向服务器传送用户口令。

LIST：用于请求服务器返回远程主机当前目录的所有文件列表。文件列表将在数据连接上传送。

RETR filename：用于从远程主机的当前目录检索文件。该命令触发远程主机发起一个数据连接，并发送文件。

STOR filename：用于向远程主机的当前目录存放文件。

常见回答为：

331 Username OK，password required

125 Data connection already open；transfer starting

425 Can't open data connection

452 Error writing file

## 因特网中的电子邮件

![mail](https://s2.ax1x.com/2019/12/18/Q7rZDK.png)

上图展示了因特网电子邮件的总体情况，其主要由三部分组成：用户代理（user agent）、邮件服务器（mail server）和简单邮件传输协议（Smiple Mail Transfer Protocol，SMTP）。

用户代理允许用户阅读、回复、转发、保存和撰写报文（用户代理也叫邮件阅读器）。邮件代理向其邮件服务器发送邮件，并且该邮件被放在邮件服务器发送报文列中。当用户想要获取邮件时，其邮件代理从他的位于邮件服务器的邮箱中获取该报文。

邮件服务器组成了电子邮件系统的核心。每个接收方在其中的某个服务器上有一个邮箱。

邮件发送过程为：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。在传递到接收方的邮件服务器时，发送方邮件服务器还要处理接收方服务器故障的问题：当发送方发送失败时，发送方邮件服务器在一个报文列表中保持该报文并在以后尝试再次发送，一般半个小时尝试一次，如果几天依然不能成功，会删除该报文并通知发送方。在接收方查看邮件时，接收方服务器会首先鉴别其身份。

SMTP是因特网电子邮件中主要的应用层协议。它使用TCP可靠传输服务。

### SMTP

SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器。SMTP邮件的主体部分（不止其首部）只能采用简单的7位ASCII码表示。

当A给B发送一封简单的ASCII报文时，其流程如下：

1）A调用他的邮件代理程序并提供B的邮件地址，撰写邮件，然后通过用户代理发送该邮件。

2）A的用户代理把报文发送给A的邮件服务器，在那里该报文被放在报文发送队列中。

3）运行在A邮件服务器上的SMTP客户机端发现报文队列中这个报文，就创建一个到运行在B的邮件服务器上的STMP服务器的TCP连接。

4）在经过一些初始SMTP握手后，SMTP客户机通过该TCP连接发送A的报文。

5）在B的邮件服务器上，SMTP的服务器端接收该报文，B的邮件服务器然后将该报文放入B的邮箱中。

6）在B方便的时候，调用用户代理阅读报文。

下图展示了该过程：

![过程](https://s2.ax1x.com/2019/12/18/Q7Rpss.png)

SMTP一般不使用中间邮件服务器发送邮件。

SMTP客户机（运行在发送方邮件服务器上）在25号端口建立一个到SMTP服务器的TCP连接。一但建立连接，服务器和客户机就执行一些应用层的握手，在握手阶段，，SMTP客户机指定发送方的邮件地址和接收方的邮件地址。之后发送报文。

下面是SMTP服务器（S,主机名是server）和SMTP客户机（C，主机名是client）之间交换报文脚本的例子，一旦创建了TCP连接，就开始下列过程：

```
S: 220 server
C: HELO client
S: 250 Hello client pleased to meet you
C: MALL FROM: <alice@crepes.fr>
S: 250 alice@crepes.fr ... Sender ok
C: RCPR TO: <bob@hamburger.edu>
S: 250 bob@hamburger.edu ... Recipient ok
C: DATA
S: 345 Enter mail, end with "." on a line by itself
C: Do you like ketchup?
C: How about pickles?
C: .
S: 250 Messgae accepted for delivery
C: QUIT
S: 221 server closing conncetion
```

上例中，客户机程序从邮箱服务器client向邮箱服务器server发送了一个报文（Do you like ketchup？How about pickles？）。客户机发送了五条命令：HELO（hello的缩写）、MALL FROM、RCPT TO、DATA以及QUIT。这些命令是自解释的。客户机通过发送一个只包含句点的行，告诉服务器该报文结束了。（按照ASCII码，每个报文以`CRLF.CRLF`结束，其中`CR`和`LF`分别表示回车和换行）。应达250表示正常。SMTP使用持久连接：如果发送邮件服务器有几个报文发往同一个接收服务器，可以通过一个TCP连接发送所有这些报文。对每个报文，客户机都用一个新的MALL FROM开始，仅当所以邮件全部发送完全才发送QUIT。

### 与HTTP的对比

相同点：都是使用了持久连接。

不同点：

1. HTTP是一个拉协议，即人们可以在方便的时候装载Web信息，即用户使用HTTP从该服务器拉取信息。TCP连接是由想获取文件的机器发起的。
2. SMTP是一个推协议，即发送邮件服务器把文件推到接收邮件服务器，TCP连接是由要发送的机器发起的。
3. SMTP要求每个报文使用7位ASCII格式。如果某报文包含了非7位ASCII字符或二进制数据，则该报文必须按照7位ASCII进行编码。

### 邮件报文格式和MIME

邮件报文要包含环境信息，这些环境信息包含在首部行中。每个首部行包含一个From首部行和一个To首部行，可以包含一个Subject首部行或其他可选的首部行。这些首部行不同于在之前所学的SMTP命令，之前的命令是SMTP握手协议的一部分，而首部行是邮件报文的一部分。但是邮件发给谁和从哪里来不是由首部行决定的，而是由SMTP命令决定的。下面展示了一个典型的报文首部：

```
From: a
To: b
Subject: Searching for the meaning oof file
```

在报文首部之后，紧接着是空白行，然后是以ACSII格式表示的报文主体。

#### 非ASCII码数据的MIME扩展

为发送非ASCII文本的内容，发送方必须在报文中使用附加的首部行。多用途因特网邮件扩展（Multipurpose Internet Mail Extension，MIME）。支持多媒体的量关键字MIME首部为Content-Type:和Content-Transfer-Encoding：。前者允许接收用户代理采取适当的动作，后者提示接收用户代理该报文已经使用了ASCII编码，并指出了使用的编码类型。当用户代理接收到包含这两个首部行的报文时，会根据Content-Transfer-Encoding的值将报文编码为非ASCII格式，然后根据Content-Type首部行决定它应该采取何种动作来处理报文。

#### 接收的报文

接收器一旦接收到具有RFC 822和MIME的首部行，就在该报文的顶端添加一个Received:首部行。该首部行定义了发送该报文的SMTP服务器的名称，接收该报文的SMTP服务器名称和接收时间。例如：`Received: from server by client; 12 Oct 98`。

### 邮件访问协议

之前我们只考虑了邮件服务器之间使用SMTP进行传输报文，现在考虑用户代理与邮箱服务器之间如何传递报文。在发件方来看，从用户代理到邮箱服务器是一个推过程，需要推协议，SMTP刚好可以按照，因此，在发送方这两者使用SMTP协议。在来看接收方，接收方是在有时间的时候去读邮件，因此是一个拉过程，需要拉协议来支持，因此不能使用SMTP。与之对应的，可以使用的协议有三种：第三版邮局协议（Post Office Protocol-Version 3，POP3）、因特网邮件访问协议（Internet Mail Access Protocol，IMAP）以及HTTP。

![整体过程](https://s2.ax1x.com/2019/12/18/QHl9js.png)

#### POP3

当用户代理（客户机）打开一个到邮件服务器（服务器）端口110上的TCP连接后，POP3就开始工作了。POP3按照三个阶段进行工作：特许（authorization）、事物处理以及更新。

第一阶段（特许）：用户代理发送（以明文形式）用户名和口令以鉴别用户。

第二阶段（事务处理）：用户代理取回报文。同时还可以进行：对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。

第三阶段（更新）：出现在客户机发出了quit命令后，目的是结束该POP3会话，这时，邮件服务器删除那些被标记为删除的报文。

在POP3事物处理阶段，用户代理发送一些命令，服务器对每个命令做出回答。回答有两种：+OK（有时后面会有说明文字），服务器用它来指示前面的命令是正常的；-ERR，服务器用它来指示前面的命令出现错误。

特许阶段主要有两个命令：user username和pass password。下面展示了这个的使用：

```
$ telnet pop.qq.com 110
Trying 59.37.97.57...
Connected to pop.qq.com.
Escape character is '^]'.
+OK QQMail POP3 Server v1.0 Service Ready(QQMail v2.0)
user 2322253097
+OK
pass ********
-ERR Please using authorized code to login. More information at http://service.mail.qq.com/cgi-bin/help?subtype=1&&id=28&&no=1001256
Connection closed by foreign host.
```

这里使用的是qq邮箱的POP3服务器。但是由于腾讯做了一个优化，输入密码时，不是之间输入qq密码，而是输入一个授权码，所以这里就报错了。

事物处理过程中。POP3用户代理发出的命令通常由用户配置为“下载并删除”或者“下载并保留”。主要有四个命令list、retr、delete和quit。命令的语法在RFC 1939中定义。大概使用如下图：

![POP](https://s2.ax1x.com/2019/12/18/QHatoj.png)

#### IMAP

IMAP服务器把每个报文与一个文件夹联系起来，当报文第一次到达服务器时，它被放到收件箱文件夹中。收件人可以把邮件移到一个新的、用户创建的文件夹中，或阅读邮件、删除邮件等。IMAP为用户提供了创建文件夹以及在文件夹中移动邮件的命令。IMAP还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件。IMAP服务器维护了IMAP会话的用户状态信息。

IMAP运行用户代理获取报文组件的命令。

## DNS，因特网的目录服务

主机使用IP地址进行标识。一个IP地址由4个字节组成，并有着严格的层次结构。如想127.7.106.83这样，每个字节都被句点分隔开，表示了0~255的二进制数。IP地址具有层次结构是因为我们从左向右扫描时，会得到越来越细的关于主机位于因特网何处的信息。

主机也可以使用主机名进行标识。不过主机名只有在DNS中注册才有用，别人才能通过DNS获得主机名，因此在DNS中，主机名一定是互异的。

### DNS提供的服务

域名系统（Domain Name System，DNS）提供进行主机名到IP地址转换的目录服务。

DNS是：1）一个由分层的DNS服务器实现的分布式数据库；2）一个运行主机查询分布式数据库的应用层协议。DNS协议运行在UDP之上。

DNS通常由其他应用层协议（如HTTP、SMTP和FTP）所使用，用于将用户提供的主机名解析为IP地址。例如，当请求URL `www.someschool.edu/index.html`页面时，为了使用户的主机能够将一个HTTP请求发送到Web服务器`www.someschool.ed`，该用户主机必须获得`www.someschool.edu`的IP地址。其做法为：

1. 同一台用户主机上运行着DNS应用的客户机端。
2. 该浏览器从上述URL中抽取出主机名`www.someschool.edu`，并将这个主机名传给DNS应用的客户机端。
3. 该DNS客户机向DNS服务器发送一个包含主机名的请求。
4. 该DNS客户机最终会收到一份回答报文，包含对于主机名的IP地址。
5. 一旦浏览器接收到来自DNS的IP地址，它就可以向该IP地址定位的HTTP服务器发起一个TCP连接。

除了进行主机名到IP地址的转换外，DNS还提供了一些重要服务：

1. 主机别名（host aliasing）：有着复杂主机名的主机可以用于一个或者多个别名。原始主机名叫做**规范主机名**（canonical hostname）。应用程序可以调用DNS来获得主机别名对于的规范主机名已经主机的IP地址。
2. 邮件服务器别名（mail server aliasing）：电子邮件应用程序调用DNS，对提供的邮件服务器别名进行解析，以获得该主机的规范主机名以及IP地址。事实上，MX记录允许一个公司的邮件服务器和Web服务器使用相同的（别名化的）主机名。
3. 负载分配（load distribution）：DNS也用于在冗余的服务器之间进行负载分配。繁忙的站点被冗余分别在多台服务器上，每台服务器均运行在不同的端系统上，有着不同的IP地址。对于这些冗余的服务器，一个IP地址集合对应于同一个规范主机名。DNS数据库存储着这些IP地址集合。当客户机为映射到这个IP地址集合的名字发出一个DNS请求时，该服务器用包含全部这些地址的报文进行回答，但每个回答中旋转这些地址的顺序。客户机通常总是向IP地址排在最前面的服务器发送请求，所以DNS就在所有冗余的服务器之间旋转分配负载。

### DNS工作机理

应用程序调用DNS的客户机端，并指明要转换的主机名，用户主机上的DNS接收到后，向网络中发送一个DNS查询报文。所有DNS请求和回答报文使用UDP数据报经端口53发送。经过若干毫秒时延后，用户主机上的DNS接收到一个DNS回答报文，这个结果被递送到调用DNS查询的应用程序中。

DNS的一种简单设计方式是在因特网上只使用一个DNS服务器，该服务器包含所有映射。但是这样会有很多问题：

1. 单点故障：如果该服务器崩溃，整个因特网随之瘫痪。
2. 通信容量：单个DNS服务器不得不处理所有DNS查询。
3. 远距离的集中式分布：单个服务器不可能接近所有查询的客户机，因此会造成严重的时延。
4. 维护：单个服务器将不得不为所以的因特网主机保留记录。使得整个中央数据库非常庞大，而且不得不解决为每个新添加的主机而频繁更新。

为此，DNS采用了分布式设计方案，DNS是因特网上实现分布式数据库的典范。

![DNS](https://s2.ax1x.com/2019/12/19/Qq8xII.png)

#### 分布式、层次数据库

有三类DNS服务器：根DNS服务器、顶级域（Top-Level Domain，TLD）DNS服务器和权威DNS服务器。他们以上图这样组织（有点像HASH的感觉）。此时查询过程为，以`www.Amazon.com`举例。首先客户机联系根DNS服务器之一，它返回顶级域名com的TLD服务器IP地址。该客户与这些TLD之一联系，它将为`amazon.com`返回权威服务器的IP地址。最后，该客户家联系权威服务器，它为`www.Amazon.com`返回IP地址。

**根服务器**：因特网上存在13个根服务器（标号A到M）。尽管我们将这13个每个视为单独的服务器，但每台“服务器”实际上是冗余服务器集群，以提供安全性和可靠性。

**顶级域服务器**：这些服务器负责顶级域名如（com、org、net、edu和gov）和所有国家的顶级域名。

**权威DNS服务器**：在因特网上具有公共可访问（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。由组织机构的权威DNS服务器来保持这些记录，或者支付费用将这些记录存储在某个服务提供商的权威DNS服务器中。

除了上面三种以外，还有一类重要的DNS，称为本地DNS服务器。本地DNS服务器严格来说不属于DNS服务器的层次结构。当主机发出DNS请求时，该请求首先被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。本地DNS服务器工作方式如下图：

![local DNS](https://s2.ax1x.com/2019/12/19/QqNNHe.png)

主机发送请求后，首先定向的本地DNS中，本地DNS联系根DNS，获得对应的TLD，在联系对应的TLD，获得权威服务器，再联系权威服务器，获得IP，返回给请求主机。

TLD服务器不一定知道每台主机的权威DNS服务器的IP地址。TLD服务器只知道中间的某个DNS服务，该中间服务器依次才能知道用于该服务器的权威DNS服务器。

上图展示的例子是递归查询（recursive query）和迭代查询（iteration query）。主机到本地服务器是递归，本地到后面的三个查询是迭代。理论上将，查询可以是完全递归的，如下图：

![recursive](https://s2.ax1x.com/2019/12/19/QqwuKx.png)

#### DNS缓存

为了改善时延性并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。DNS缓存（DNS caching）原理十分简单：在请求链中，当一个DNS服务器接收到一个DNS回答时，DNS将回答中的信息缓存在本地存储器中。由于主机和主机名与IP地址映射不是永久的，所以DNS服务器在一段时间后将丢弃缓存信息。

### DNS记录和报文

实现DNS分布式数据库的所有DNS服务器共同存储着**资源记录**（Resource Record，RR），RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记录。

资源记录是一个包含了下列字段的4元组：

```
(Name, Value, Type, TTL)
```

TTL是该记录生存时间，它决定了资源记录应当从缓存中删除的时间。Name和Value的值取决于Type：

| Type  | Name含义          | Value含义                                           |
| ----- | ----------------- | --------------------------------------------------- |
| A     | 主机名            | IP地址。                                            |
| NS    | 域（如`foo.com`） | 知道如何获得该域中主机IP地址的权威DNS服务器主机名。 |
| CNAME | 别名              | 规范主机名                                          |
| MX    | 别名              | 邮件服务器的规范主机名                              |

为了获得邮件服务器的规范主机名，应该请求一条MX记录，为了获得其他服务器主机名应该请求一条CNAME记录。

如果一台DNS服务器是指定某特定主机的权威DNS服务器，那么该DNS服务会有一条包含该主机名的A记录。如果DNS服务器不是某个主机名的权威DNS服务器，那么该服务器包含一条NS记录（我觉得NS记录应该不是在服务器中存储的，应该是更具请求生成的），该记录对应于包含主机名的域；还有一条A记录，该记录提供了在NS记录中的Value字段中DNS服务器的IP地址。

#### DNS报文

DNS只有两种报文，并且查询和回复有着相同的格式，如下图：

![DNS packet](https://s2.ax1x.com/2019/12/19/Qq2Mp8.png)

DNS报文中各字段语义如下

1）前12个字节是首部区域，其中有几个字段。第一个字段是16比特的数，用于标识该查询。这个标识符会被复制到对查询的回答的报文中，以便让客户机用它来匹配发送的请求和接收到的回答。标识字段中有多个标志。1比特的“查询/回答”标识位指出是查询报文（0）还是回答报文（1）。当某DNS服务器正好是被请求主机的权威DNS服务器时，1比特的“权威的”标识位被置位在回答报文中。如果客户机（主机或者DNS服务器）希望DNS服务支持递归查询，将设置1比特的“希望递归”标志位。如果该DNS服务器支持递归查询，则回答报文中会对1比特的“递归可以”标志位置位。在该首部还有4个“数量”字段，指出在首部后四类数据区出现的数量。

2）问题区域包含着正在进行的查询信息。该区域包括：1.名字字段，用于指出正在被查询的主机名字。2.问题字段，用于指出正被查询的问题类型（A、MX等）。

3）来自DNS服务器的回答报文中，回答区域包含了对最初请求的名字的资源记录（RR）。一个回答报文的回答区域可能有多条RR，因为一个主机名可能对应多个IP地址。

4）权威区域包含了其他权威DNS服务器的记录。

5）附加区域包含了一些有帮助的信息。

可以使用`nsloopup`程序来进行DNS查询。该程序的使用命令是：

```
nslookup -qt=type domain [DNS-server];
//例如
nslookup -qt=mx baidu.com 8.8.8.8
```

#### 在DNS数据库中插入记录

当向某些注册登记机构注册域名`networkutopia.com`时，需要向该机构提供基本权威DNS服务器和辅助权威DNS服务器的名字和IP地址（不是域名本身的IP地址）。假定该名字和IP地址是`dns1.networkuptopai.com`和`dns2.networkuptopai.com`已经`212.212.212.1`和`212.212.212.2`。对这两个权威DNS服务器的每一个，该注册机构确保将一个类型NS和一个类型A的记录输入到TLD com服务器。如：

```
(networkuptopia.com,dns1.networkuptopai.com,NS)
(dns1.networkuptopai.com, 212.212.212.1, A)
```

此时查询时，首先TLD com回复本地DNS一个NS信息，而后本地DNS再次查询TLD com获取含义`networkuptopia.com`的权威服务器地址，这里是`212.212.212.1`。而后查询权威DNS服务器来获取IP地址。

## P2P应用

### P2P文件分发

在P2P文件分发中，每个对等方都能够重新分发其所有的该文件的任何部分，从而协助服务器进行分发。

#### P2P体系结构的扩展性

下图展示了文件分发的示意图，其中所有字母的含义如图所示：

![file](https://s2.ax1x.com/2019/12/19/QLP6Qf.png)

对于客户机/服务器的体系结构来说，将文件传输给所有客户机总时间受两个限制，一个是服务器上传N份文件所需要的总时间，另一个是下载最慢的服务器下载整个文件所需时间，因此客户机/服务器体系结果总的分发时间满足：
$$
D_{cs} >= max\{\frac{NF}{u_s}, \frac{F}{d_{min}}\}
$$
对于P2P体系结构来说，分发总时间受三方面限制，第一是服务器发送一份完整的文件出去的时间，第二是下载最慢的主机下载完文件的时间，第三是所有主机上传N份文件的时间。因此P2P文件分发时间满足：
$$
D_{P2P} >= max\{\frac{F}{u_S},\frac{F}{d_{min}}, \frac{NF}{u_s+\sum_i^N{u_i}}\}
$$

#### BitTorrent

BitTorrent是一种用于文件分发的流行P2P协议。用BitTorrent的术语来说，参与一个特定文件分发的所有对等方的集合称为一个洪流（torrent）。每个洪流具有一个基础设施节点，称为追踪器。当一个对等方加入洪流时，它向追踪器注册，并周期性的通知追踪器它任然在洪流中。追踪器以这种方式跟踪洪流中的对等方。

![BitTorrent](https://s2.ax1x.com/2019/12/19/QLeTqx.png)

当新对等方加入洪流时，追踪器随机的从对等方集合中选择一些对等方，如50个，并将这50个对等方的IP地址发送给新的对等方。新的对等方持有对等方的这张列表，试图与该列表上的所有对等方创建并行的TCP连接。我们称所有与新对等方成功建立TCP连接的对等方为“邻近对等方”。

这里新的对等方为Alice。Alice周期性地询问每个邻近对等方它们所具有的块列表。如果Alice有L个邻近对等方，那么将会获得L个块列表，此时其就可以对自己当前还没有的块发出请求。

Alice将做两个决定，第一，她应该向她的邻居请求那些块？第二，她所拥有的块应该发送给哪个邻居。

对于请求哪个块，Alice采用一种称为最罕见原则（rarest first）。该原则思想是，根据她没有的块从她的邻居中确定那些最稀缺的块（即L列表中出现最少的块），并优先请求最稀缺的块。这样，最稀缺的块更迅速地重新分发，其目标是均衡每个块在洪流中拷贝数量。

为了决定她响应哪个请求，基本想法是Alice确定其邻居的优先权，这些邻居是那些当前能够以最高的速率供给它数据的。特别的，Alice对于她的每个邻居都持续地测量接收到比特的速率，确定以最高速率流入的四个邻居，然后，她将数据发给这4个邻居。每过10秒，她重新计算该速率并可能修改这四个对等方。更重要的是，每过30秒，她要随机地选择一个另外的邻居并向他发送块。我们将这个随机的对等方称为Bob。因为Alice给Bob发送数据，所以她可能成为Bob前4位上载者之一，这样Bob向Alice传输数据。如果Bob向Alice发送数据速率足够高，他也可能成为Alice的前四个上载者之一。换言之，每过30秒，Alice随机选择一个新的对等方并开始传输数据。如果这两个对等方都满足此对换要求，那么会将对方放入到其前四位列表中并继续与对方进行对换，直到对等方之一发现更好的伙伴为止。

### 在P2P区域中搜索信息

#### 集中式索引

在集中式索引中，由一台大型服务器（或服务器场）来提供索引服务。该方法存在几个缺点：

1. 单点故障：服务器崩溃，整个P2P崩溃。
2. 性能瓶颈好基础设施费用。
3. 侵犯版权。

#### 查询洪泛

查询洪泛是建立在Gnutella协议之上的。在Gnutella中，对等方形成一个抽象的逻辑网络，该网络被称为覆盖网络。如果对等方X和对等方Y维护了一个TCP连接，那么我们说X和Y之间有一条边。在这种设计中，对等方通过已经存在的TCP连接，向覆盖网络中相邻的对等方发送报文。当Alice要定位一个文件位置时，她向所有邻居发送一条查询报文。Alice的邻居向它们的所有邻居转发该报文，邻居的邻居会接着转发。当一个对等方接收到查询报文时，将检测查询内容是否与可供共享的任何文件相匹配，如果存在匹配，则按查询的路径反向传播回去，向Alice回送一条查询命中（递归式）。、

该方法会在网络中产生大量流量，为解决该问题使用了范围受限查询洪泛。具体来说，就是在查询时添加一个计数，每到下一层就将计数减一。如果到0了，即使没有查到也不再向外扩散。

这里讨论当X加入覆盖网络的过程：

1）对等方要首先发现某些已经位于覆盖网络的其他对等方。解决这种引导跨接问题的方法之一是，让X维护一张对等方列表（IP地址），这些对等方常在覆盖网络中开机；另一种方法是，X能够联系维护这种列表的跟踪站点。

2）一旦访问了这样一张表，X接下来试图与该表上的对等方建立一个TCP连接，直到与某个对等方Y创建连接为止。

3）对等方向Y发送一个Ping报文，该ping报文包括对等方计数字段。Y接收到Ping后转发ping，直到Ping等于0.

4）只要一个对等方Z接收到ping，它通过覆盖网络向X发送一个pong报文，该报文包含Z的IP地址。

5）当X接收到pong报文后，就知道到了网络中许多的IP地址，可以建立连接。

#### 层次覆盖

层次覆盖结合了上述两种方法的优秀特征。层次覆盖不使用专用的服务器来跟踪和索引文件。在层次覆盖中并非所有对等方是平等的，具有高速连接并具有高可用性的对等方被指定为超级对等方。每个非超级对等方都被指定为一个超级对等方的子对等方。一个新的对等方与超级对等方建立一个TCP连接，新对等方将可共享文件告诉超级对等方。这样，每个超级对等方就成为一个小的索引。超级对等方之间互相建立TCP连接，从而形成覆盖网络。超级对等方可以向其邻居超级对等方转发查询。该方法类似于查询洪泛，但覆盖网络中超级对等方仅使用了受限查询洪泛。

### 分布式散列表

在该书第六版中将前一节的三部分全部删除了，添加了一个分布式散列表用来P2P区域中搜索。说明该方法应该是当前最好使的，使用最广泛的，前三个可能已经弃用了。但是第七版又把这个也删了，表示很迷。

分布式散列表（Distributed Hash Table，DHT）是一个分布式数据库，在数以万计的对等方中存储（键，值）对。在每个对等方将保持（键，值）对仅占总体的一个小子集，允许任何对等方使用一个特别的键查询该分布式数据库。分布式数据库则能够定位拥有该相应（键，值）对的对等方，然后向查询的对等方返回该（键，值）对。任何对等方也将允许在数据库中插入新键值对。

首先为每个对等方分配一个标识符，其中每个标识符是一个[0, 2^n-1]范围内的整数，n取某些固定的值。我们也要求键是同一范围内的一个整数。通过散列函数将键映射到该范围。

现在考虑DHT中存储（键，值）对问题，该问题核心是对等方键的分配。给定每一个对等方一个整数标识符，每个键也会被映射到标识符对应的范围。这里需要定义“最近邻”，最近邻是指键的最邻近后继。假设n是4，键都落在[0,15]之内，假设该对等方存在8个对等方，标识符分别为1、 3、 4、 5、 8、 10、 12和15，此时要存储（11，something）时，就一个存储在标识符为12的对等方上。

当我们要插入一个键值对时，之间通过计算该存储放到哪个对等方（假如可以获得），然后之间联系该对等方是可以的，但是这有个规模的问题，这样的话要求每个对等方存储所有其他对等方的IP，这是不合理的。为此，我们设计了环形DHT。

#### 环形DHT

![DHT](https://s2.ax1x.com/2019/12/20/QXZncd.png)	

这里我们将对等方组织成一个环，每个对等方只需要与它的直接后继和直接前驱联系（环状双向链表）。当对等方3要确定谁复制11时，首先其生成一个报文传递给其后继，该报文沿顺时针方向传输。每个接收到该报文的对等方，由于知道其前驱节点和后继节点因此知道是否该由自己负责该键值对，如果不负责，则将报文传递给后继节点。直到找到该负责次节点的对等方为止。<font color=red>（问题1：如果DHT中没有大于该键的最近邻咋办？可能进入DHT的第一个对等方与服务器连接时，被分配为标识符为2^n-1）</font>

只有前驱和后继也造成了一个问题是，每次查询和插入的平均发送N/2条报文。这也是不太合理的，因此每个对等方要跟踪的邻居数量与DHT为解析一个查询而需要发送的 报文数量之间存在着折中。细化方案之一是以环形网络为基础，但添加捷径，使每个对等方不仅联系其直接前驱和直接后继，而且联系分部在环上的捷径对等方。如上图的b，此时当某个对等方收到报文时，不仅传输给后继报文，也传递给与其相连的捷径上。

研究表明，DHT能够被设计成每个对等方的邻居数量以及每个请求报文数量均为O(logN)。这是一种比较令人满意的折中。<font color = red>问题2：哪些对等方被选则为捷径的目标节点，以及如何获取这些对等方的IP）</font>

#### 对等方的扰动

在DHT中，对等方可以不加警示的到来和离开，为了处理这个问题，我们要求对等方要知道其第一个和第二个后继，以及要周期性的证实它的两个后继是否存活（如周期性发送ping报文并寻求响应）。现在假设上图a中5突然离开，此时,5将不在响应ping报文，在离开之前的对等方3和4知道了5离开，此时4和3将更新其后继信息。(4先更新，再更新3）<font color=red>问题3：离开的对等方里面存储的键值对如何再被重新分配，还有以该对等方为捷径的对等方如何更新捷径</font>

下面讨论一个对等方加入时发送的事情，新的对等方加入时，会知道编号最小的已经存在的对等方的IP，这里是1（应该是有一个服务器来维护这个信息，每个对等方进入DHT时，首先联系该服务器）。然后向该对等方发送查询信息，获得其前驱和后继（可能这个时候也可以创建捷径，但具体操作呢）。而后插入进去，即可。

更多关于DHT的内容可以查看Kademlia相关内容。



## 视频流和内容分发网

### 因特网视频

视频是一系列的图像，通常以一种恒定的速率来展示。视频能够被压缩。可用比特率来衡量视频质量。比特率越高，质量越好。

### HTTP和DASH

在HTTP流中，视频只是存储在HTTP服务器中作为一个普通文件，每个文件有一个特定的URL。当用户看视频时，客户与服务器创建一个TCP连接并发送对该URL的HTTP GET请求。服务器以底层网络协议和流量条件允许的尽可能快的速率，在一个HTTP响应报文中发送该视频文件。客户端，字节被收集在应用缓存中，一旦该缓存中的字节数量超过预先设定的门限，客户端应用程序就开始播放。特别的，流式视屏应用程序周期性的从客户应用程序缓存中抓取帧，解压缩并在屏幕上展示。

在不同客户与不同时间，客户的可用带宽不同，这导致了一个新型基于HTTP的流的研发，被称为经HTTP的动态适应流（Dynamic Adaptive Streaming over HTTP，DASH）。在DASH中，视频编码为几个不同版本，其中每个版本具有不同的比特率，对应于不同质量水平。客户动态请求来自不同版本且长度为几秒的视频段数据块。当可用带宽较高时，客户自然地选择来自高速率版本的块，当可用带宽较低时，客户自然的选择来自较低速率版本的块。

使用DASH后，每个视频版本存储在HTTP服务器中，每个版本都有一个不同的URL。HTTP服务器也有一个告示文件（manifest file），为每个版本提供了一个URL及其比特率。客户请求告示文件，获得不同版本。然后客户通过在HTTP GET请求报文中对每块指定一个URL和一个字节范围，一次选择一块。在下载块的同时，客户端也测量接受带宽并运行一个速率决定算法来选择下次请求的块。

### 内容分发网

建立单点服务器是最简单的方法，但存在二个弊端：

1. 若客户远离数据中心，服务器到客户从分组将跨越许多通信链路，会造成严重时延。
2. 视频可能经过相同的通信链路发送多次，这造成了网络带宽的浪费，视频公司也要向因特网发送相同字节而向其ISP运营商支付费用。

因此，主要视频流公司都利用内容分发网（Content Distribution Network，CDN）。CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频（和其他类型的Web内容，包括文档、图片和音频）的副本，并且所有试图将每个用户请求定向到一个提供最好用户体验的CDN位置。CDN可以是专业CDN，也可以是第三方CDN。

CDN通常采用两种不同的服务器安置原则：

1. 深入：通过在遍及全球的接入ISP中部署服务器集群来深入到ISP接入网中。
2. 邀请做客：通过在少量关键位置建造大集群来邀请到ISP做客。不是将集群放在接入ISP中，这些CDN通常将他们的集群放置在因特网交换点（IXP）。

一旦CDN的集群准备就绪，就可以跨集群复制。而一般采取的是拉策略：如果一个客户向未存储该视频的集群请求某视频时，该集群检索该视频（从某中心仓库或者另一个集群），向客户端流式传输视频的同时在本地存储一个副本。

#### CDN操作

当用户主机中的一个浏览器指令检索一个特定视频（URL）时，CDN必须截获请求，以便能够：1）确定此时适用于该客户的CDN服务器集群；2）将客户请求重定向到该集群的某台服务器。

大多数CDN利用DNS来截获和重定向请求。考虑一个简单的例子来说明通常是如何涉及DNS的。假定一个内容提供商netcinema雇佣了第三方CDN公司kingcdn来向客户分发视频。在netcinema的web网页上，它的每个视频被指派了一个URL，该URL包含一个字符串“video”以及该视频本身的独特标识符，如转化器7可以指派为http://video.netcinema.com/6Y7B23V。接下来出现下图的步骤：

![CDN](https://s2.ax1x.com/2020/01/11/l50po8.png)

1. 用户访问位于netcinema的Web网页。
2. 当用户访问http://video.netcinema.com/6Y7B23V时，该用户主机发送一个对于video.netcinema.com的DNS请求。
3. 用户的本地DNS服务器（LDNS）将该DNS请求中继到一台用于netcinema的权威DNS服务器，该服务器观察到主机名video.netcinema.com中的字符串“vedio”。为了将DNS请求移交给kingcdn，netcinema权威DNS服务器并不返回一个IP地址，而是向LDNS返回一个kingcdn域的主机名，如a1105.kingcdn.com。
4. 从这时起，DNS请求进入了kingcdn专用DNS基础设施。用户的LDNS发送第二个请求，此时是对a1105.kingcdn.com的DNS请求，kingcdn的DNS系统最终向LDNS返回kingcdn内容服务器的IP地址。正是在这里，在kingcdn的DNS系统中，指定了CDN服务器，客户将能够从这台服务器接收到它的内容。
5. LDNS向客户主机转发内容服务CDN节点的IP地址。
6. 一旦客户收到kingcdn内容服务器的IP地址，它与具有该IP地址的服务器建立一条直接的TCP连接，并且发出对该视频的HTTP GET请求。如果使用DASH，服务器将首先向客户机发送具有URL列表的告示文件，每个URL对应视频的每个版本，并且客户机动态的请求不同版本的块。

#### 集群选择策略

任何CDN部署，其核心是集群选择策略，即动态地将客户定向到CDN中某个服务器集群或数据中心的机制。CDN一般采用专用的集群选择策略。

一种简单的策略是指派客户到地理位置的最为邻近的集群。使用商用地理位置数据库，每个LDNS IP地址都映射到一个地址位置。当从一个特殊的LDNS接收到一个DNS请求时，CDN选择地理位置上最为接近的集群。但这存在问题，即地理位置最近的集群不一定是就网络路径长度与跳数而言的最近。同时，该策略忽略了时延和可用带宽随因特网路径时间而变化，总是为特定的客户指派相同的集群。

CDN能够对其集群和客户之间的时延和丢包性能执行周期性的实时测量。

# 第三章 运输层

## 概述和运输层服务

运输层协议为运行在不同主机上的应用进程提供了逻辑通信。运输层在端系统中实现而不是在网络路由器中实现。在发送方，运输层接收来自上层的的报文转换成运输层分组：将应用报文划分为较小的块，并为每一块加上运输层首部来创建运输层报文段。在发送方体统中，运输层将这些报文段传输给网络层，网络层将其分装进网络层分组并向目的地发送。网络路由器只作用于数据报的网络层字段，即他们不检查分装在该数据报的运输层报文段的字段。

### 运输层与网络层的关系

运输层为运行在不同主机上的进程之间提供逻辑通信，而网络层提供了主机之间的逻辑通信。运输层协议只工作在端系统。运输层协议所能提供的服务也受到底层网络层协议的服务模型的限制，然而，即使网络层不提供响应的服务，运输层协议也能提供某些服务。

### 因特网运输层概述

运输层为应用层提供了两种截然不同的协议：UDP（用户数据报协议）和TCP（传输控制协议），前者提供一种不可靠的无连接服务，后者提供了一种可靠的面向连接的服务。

网络层协议叫IP（网际协议），IP为主机之间提供了逻辑通信。IP的服务模型是尽力而为交付服务（best-effort delivery service）。即IP尽最大努力交付报文段，但不作任何保证。特别的，它不确保报文段的交付，不确保报文段的按序交付，不确保报文段的完整性。因此IP被称为不可靠服务。每台主机至少有一个网络层地址，即所谓的IP地址。

TCP和UDP的基本任务：将两个端系统间IP的交付服务扩展到运行在两个端系统的进程之间的交付服务。将主机间交付扩展到进程间交付，称为运输层的多路复用与多路分解。UDP和TCP还通过在其报文段首部添加差错检测字段而提供完整性检查。进程数据交付和差错检测是两种最低限度的运输层服务，也是UDP所提供的仅有的两种服务。

TCP还提供几种附加的服务，首先提供了可靠数据传输。通过使用流量控制、序号、确认和定时器等技术。TCP确保正确的、按序的将数据从发送进程交付到接收进程，这样TCP将两个端系统之间不可靠的IP服务转换为一种可靠的进程间数据传输服务。TCP还提供拥塞控制，TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。

## 多路复用与多路分解

进程有一个或多个套接字，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。

首先考虑接收主机如何如何将一个收到的运输层报文定向到合适的套接字。为实现这一要求，每个运输层报文段中设置几个字段，在接收端，运输层检测这些字段并标识出接收套接字，然后将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。从源主机的不同套接字中收集数据块，并为每一个数据库封装上首部信息从而生成报文段，然后将报文段传递到网络层的工作叫做多路复用。

运输层多路复用的要求：

1. 套接字有唯一标识符。
2. 每个报文段有特殊字段来指示该报文段要交付的套接字。

![packet](https://s2.ax1x.com/2019/12/24/lCcy9g.png)

端口号是一个16比特的数字，其大小在0~65535之间。[0,1023]的端口被称为周知端口，是受严格限制的。

### 无连接的多路复用与多路分解

创建UDP套接字时，运输层自动为套接字分配一个端口号（也可以自己指定）。

一个UDP套接字是由一个包含目的IP地址和目的端口号的二元组来全面标识。

### 面向连接的多路复用与多路分解

TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的。特别的，两个具有不同源IP地址或源端口的到达的TCP报文段将被定向到两个不同的套接字，除非TCP请求了初始创建连接的请求。

## 无连接传输：UDP

UDP只做了运输协议能够做的最少工作。除了多路复用/多路分解功能以及一些轻型的差错检验外，几乎没有对IP增加别的东西。使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有进行握手，因此UDP被称为无连接的。

使用UDP的原因：

1. 应用层可以更好的控制要发送的数据和发送的时间。UDP不提供拥塞控制，数据传递给UDP后会立即打包并传递给网络层。
2. 无需建立连接：因此不会引入建立连接的时延。
3. 无连接状态：TCP需要在端系统中维护连接状态，UDP不维护连接状态，某些应用专门使用UDP以便能够支持更多的活动客户机。
4. 分组首部开销小。

### UDP报文段结构

![UDP struct](https://s2.ax1x.com/2019/12/24/lCIr4I.png)

应用数据是应用层传递来的数据。通过端口号可以使目的主机将应用数据交付到运行在目的端系统的相应进程。接收主机使用校验和来检查报文段中是否存在差错。

### UDP校验和

UDP校验和提供了差错检验功能，即检验和用于确定当UDP报文段从源主机到达目的时，其中的比特是否发送变化（例如，由于链路中或者路由器中存储数据时的噪声干扰）。发送方的UDP对报文中的所有16比特字的和进行反码运算，求和时遇到的所有溢出都要被回卷，得到的结果放到UDP报文段中的校验和字段。

举例：

假定我们有3个16比特字：

```
0110011001100000
0101010101010101
1000111100001100
```

此时求和过程为：

```
0110011001100000
0101010101010101 +
----------------------
1011101110110101
1000111100001100 +
----------------------
0100101011000010
```

注意，这里第二次相加时，最高位溢出，回卷加到最低位。反码是将所有0换成1，1换成0。所以此时该UDP报文的校验和是`1011010100111101`。在接收方将全部4个比特字（包括校验和）一起相加。如果分组中无差错，则这个和全是1，否则存在一个0就表面分组中出现错误。

某些UDP实现只是丢弃受损的报文段，其余实现是将受损的报文段交给应用程序并警告。

## 可靠数据传输原理

![reliable](https://s2.ax1x.com/2019/12/24/lCbn0S.png)

上图说明了我们数据传输的接口。通过rdt_send()函数，可以调用数据传输协议的发送方。它将要发送的数据交付给接收方上层（rdt表示可靠数据传输协议，_send表名发送方被调用）。在接收方，当分组从信道的接收端抵达时，调用rdt_rcv()。当rdt协议想向上层交付数据时，通过调用deliver_data()完成。

本节中，只考虑单向数据传输的情况，从发送方到接收方。可靠的双向数据传输的情况从概念上讲不会更难。rdt的发送和接收方都需要通过调用udt_send()发送分组给对方（其中udt表示不可靠传输协议）。

### 构造可靠传输协议

#### 完全可靠信道上的可靠数据传输协议：rdt1.0

首先考虑最简单的情况，即底层信道是完全可靠的。下图展示了rdt1.0发送方和接收方的有限状态机(FSM)定义：

![rdt1.0](https://s2.ax1x.com/2019/12/24/lPVAaQ.png)

FSM箭头指示了从一个状态变迁到另一个状态。上图发送方和接收方都只有一个状态。此时，有完全可靠的信道，接收方就不需要提供任何反馈给发送方了。

#### 具有比特差错信道上的可靠数据传输：rdt2.0

更底层信道模型是分组中比特可能受损。

首先考虑人们对于该问题的处理。通常情况下，接收者听到、明白、记下每句话可以说“OK”。如果消息接收者听到一句含糊不清的话，可能请求重复那句话。这种口头消息协议使用了肯定确认（positive acknowledgment）与否定确认（negative acknowledge）。在计算机网络中基于这种重传机制的可靠数据传输协议称为自动重传请求（Automatic Repeat reQuest，ARQ）协议。

一般来说，ARQ协议中需要另外三种协议来处理存在的比特差错：

1. 差错检测：运输层添加的校验和字段。还有别的方式。
2. 接收方发送反馈：回复肯定确认（ACK）还是否定确认（NAK）。
3. 重传：接收方收到有差错的分组，发送方重传。

![rdt2.0](https://s2.ax1x.com/2019/12/24/lPepB8.png)

注意，当发送方在`wait-for-ACK-orNAK`状态时，它不能从上层获得更多的数据，也就是说，rdt_send()不会出现，仅当收到ACK并离开该状态时才能继续获得数据。因此发送方不会发送一块新数据，直到发送方确信接收方已经正确接收到当前分组为止。由于这种行为，类似于rdt2.0的协议被称为停等（stop-and-wait）协议。

rdt2.0存在一个致命的缺陷，即没有考虑到ACK或NAK分组受损的可能性。处理ACK与NAK受损时要考虑以下三种可能解决方案：

1. 接收到ACK或NAK受损的一方，再次发送NAK，即数据受损，但这样会无线循环下去，该方式不行。
2. 增加足够的检验和比特使发送方不但能够检测比特受损，还可以恢复当前分组。
3. 当发送方收到含糊不清的ACK或NAK时，只用重发当前数据分组即可。但这种方法在接收方到发送方中引入了冗余分组（duplicate packet）。冗余分组的根本困难在于接收方不知道它上次发送的ACK或NAK是否被发送方正确地收到，因此它无法事先知道接收到的分组是新的还是一次重发的。

现在普遍采用的是方法三，这里解决冗余分组的方法是在数据中添加一个新字段，让发送方对其数据分组进行编号，即将发送的数据分组序号放在该字段。此时接收方只需检查序号即可知道是重传的一个还是新发的一个。对于停等协议，只需要1比特序号就足够了。

![rdt2.1 sender](https://s2.ax1x.com/2019/12/24/lPMAOI.png)

![rdt2.1 receiver](https://s2.ax1x.com/2019/12/24/lPMk6A.png)

对于发送方来说，发送完成之后等待对该次分组的确认，如果接收到的确认消息被损坏或者是NAK则重发，直到收到未被损坏的确认消息且确认消息为ACK，则进入下一个状态（等待下一次调用）。

对于接收方来说，接收到数据被损坏就会发送NAK并等待重发的数据。直到重发的数据没有被损坏，则发送ACK确认，并进入下一个状态（等待接收下一个分组）。如果接收到的分组不是现在等待的分组，则说明前一个ACK消息被损坏，发送方又重发了一个已经接收到的消息，且发送方未正确进入到下一个状态（因为没有正确接收到ACK），于是接收方此时应该再次发送ACK确认信息即可，直到发送方正确接收到ACK并进入了下一个状态发送了分组。

再进一步，我们希望只有ACK确认信号而没有NAK信号，此时我们只需要在ACK信号上再绑定应该序号即可，此时也能实现上面的要求，此时在发送方如果收到了要等待的ACK对应的编号与实际收到的不一致时，等同于收到了NAK信号（发送的ACK信号对应编号是已经确认收到的信号，与要等待的不一致说明当前这次发送的分别没有被正确接收），需要重复。

![rdt2.2 sender](https://s2.ax1x.com/2019/12/24/lP39HI.png)



#### 具有比特差错的丢包信道上的可靠数据传输：rdt3.0

现在假定处理比特受损外，底层信道还有可能丢包。这里，我们让发送方负责检测和恢复丢包。假设发送方传输一个数据分组，分组本身丢包或者接收分组后确认分组的ACK发生丢失。这两种情况下，发送方都收不到应当到来的响应。如果发送方愿意等待足够长时间以便确认分组已丢失，则只需要重传该分组即可。

![rdt2.2 3.0 receiver](https://s2.ax1x.com/2019/12/24/lP8HfK.png)

上图的接收到即适合与rdt2.2也适合与接下来的rdt3.0。

从发送方角度来看，重传是万能的，发送方不知道一个数据分组丢失、一个ACK丢失，还是该分组或ACK只是过度迟延。在所有情况下采用相同动作，即重传。为实现基于时间的重传机制，需要一个倒数计时器（countdown time），在一个给定的时间过期后，可中断发送方。因此发送方需要能做到：

1. 每次发送一个分组（即第一次分组和重传分组）时便启动一个定时器。
2. 响应定时器中断（采取适当的动作）。
3. 终止定时器。

![rdt3.0](https://s2.ax1x.com/2019/12/24/lPJ2qJ.png)

这里在等待上层调用时会收到ACK是因为冗余数据导致的，因此可直接忽略。

下图展示了rdt3.0所遇到各种情况是如何工作的：

![rdt3.0](https://s2.ax1x.com/2019/12/24/lPJqqH.png)



### 流水线可靠数据传输协议

rdt3.0是一个功能正确的协议，但并非人人都能满足其性能，rdt3.0的核心问题是其为停等协议，会遭到带宽利用率底下。

解决这种性能问题的一个简单方法是：不使用停等方式运行，运行发送方发送多个分组而无需等待确认。流水线技术可对可靠数据传输协议带来如下影响：

1. 必须增加序号范围。
2. 协议的发送方与接收方必须缓存多个分组，发送方最低限度应当缓存那些已经发送但未确认的分组。
3. 所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、损坏以及过度延时分组的方式。

解决流水线差错恢复有两种基本方法：回退N步（Go-Back-N）和选择重传。

### 回退N步

在回退N步（GBN）中，允许发送方发送多个分组（当有时）而不需要等待确认，但也受限于在流水线中未确定的分组数不能超过某个最大允许数N。

![GBN](https://s2.ax1x.com/2019/12/24/lPNWZQ.png)

上图展示了GBN协议的序号范围。将基序号（base）定义为最早的未确认分组的序号，将下一个序号（nextseqnum）定义为最小的未使用（即下一个待发送）序号，则可将序号范围分成四部分。那些已发送而未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口向前滑动。N被称为窗口长度，GBN协议常被称为滑动窗口协议。

一个分组的序号承载在分组首部的一个固定长度的字段中。如果字段长度是K，则序号范围是[0,2\^k-1]。所有涉及序号的运算必须使用摸2\^k运算。

![GBN FSM](https://s2.ax1x.com/2019/12/24/lPafCn.png)

对于发送方来说：首先上层调用时，判断是否是超过了N，如果没有，则发送数据，并且判断该发送是否为唯一一个未被确认的发送，如果是，启动计时器。而后更新nextseqnum，如果超过N了，则拒绝发送数据。当收到ACK时，ACK传递的编号是接收方已确定接收到的值。此时即可更新base值。如果更新后的base值与nextseqnum值一致，说明所有传输的分组都已经确认了，此时关闭计时器，否则重新开始计时。当计时器超时时，将base到nextseqnum-1之间已经传输的数据重传。其他情况忽略（不采取动作）。

对于接收方来说：当接收到数据且没有被损坏且是期望到底的组，就接收该组，并发送ACK数据，报告已经接收到的组编号到了哪，并将期望到达的组编号加一。因此对于接收方来说，其期望数据是按序到达的，如果无效将导致发送方的重传。其他情况下，将发送之前的ACK确认信息。

GBN期望传输时是有序到达的，该方法的优点是：接收方缓存简单，接收方不用缓冲任何失序分组。因此，虽然发送方必须维护窗口的上下边界及nextseqnum在该串口的位置，但接收方只需要维护下一个按序接收的分组序号（exceptedseqnum）。该方法的缺点是：随后对该分组的重传也许会丢失或出错，因此甚至需要更多的重传。

### 选择重传

选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免不必要的重传。

![SR](https://s2.ax1x.com/2019/12/24/lPB0Ig.png)

SR发送方所采取的各种动作：

1. 从上层收到数据：当从上层收到数据时，SR发送方检测下一个可用于该分组的序号，如果序号在发送方的窗口内，则将数据打包并发送，否则像GBN一样，要么返回上层要么缓冲起来。
2. 超时：定时器再次被用来防止超时，不过对于每个分组必须用于自己的逻辑定时器。因为超时后只能发送一个分组。
3. 收到ACK。如果收到ACK，且该分组在窗口内，则SR发送方将那个被确定的分组标记为已接收。如果该分组等于send_base，则窗口基序号向前移动到具有最小序号的未确定分组处。如果窗口移动了，并且有序号落在窗口内的未发送分组，则发送该分组。

SR接收方所采取的各种动作：

1. 序号在[rcv_base, rcv_base+N-1]内的分组被正确接收。此时，收到的窗口落在接收方的窗口内，一个选择ACK分组被回送给发送方。如果该分组是以前没有收到的分组，则被缓存。如果该分组序号等于接收窗口的基序号rcv_base，则该分组以及以前缓冲的序号连续的分组（起始于rcv_base）交付给上层。然后，接收窗口按向上交付的分组数量向前移动。
2. 序号在[rcv_base-N, rev_base-1]内的数据被正确接收到。此时说明之前对该序号分组的ACK未被发生方正确接收，此时必须产生一个ACK信号。
3. 其他情况，忽略该分组。

![SR](https://s2.ax1x.com/2019/12/24/lPrqUO.png)

上图展示了一个SR的实例。

对SR协议来说，发送方与接收方的窗口并不总是一致。当我们面对有限序号实现时，不同步的窗口将会导致严重后果。如，对于一个有4个分组序号0,1,2,3的有限范围且窗口长度为3，假定发送了分组0到2，接收方也正确接收了它们。此时接收窗口落到了4,5,6个分组上，其序号为3,0,1。此时考虑两种情况，情况1如下图a，对前三个分组的ACK丢失，发送方要重传这些分组，因此接收方下一步要接收序号0的分组，即第一个发送分组的拷贝。第二种情况如下图b所示，前三个分组被正确交付，因此发送方向前移动窗口并发送4,5,6个分组，其序号是3,0,1。序号3的分组丢失，但序号0的分组到达。

![SR EX](https://s2.ax1x.com/2019/12/24/lPrbVK.png)

上述两种情况对于接收者来说是无法分辨的。显然窗口大小是有限制的，实际窗口长度必须小于或等于序号空间大小的一半。

下表展示了可靠数据传输机制及其用途的总结：

| 机制         | 用途和说明                                                   |
| ------------ | ------------------------------------------------------------ |
| 检验和       | 用于检测在一个传输分组的比特错误。                           |
| 定时器       | 用于检测超时/重传一个分组，可能由于该分组（或其ACK）丢失，可能传输超时。 |
| 序号         | 用于从发送方流向接收方的数据分组按序排号。所接收分组的序号间的空隙可使该接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余拷贝。 |
| 确认         | 接收方用于告知发送方一个分组或一组分组已经被正确地接收到。   |
| 否定确认     | 接收方用于告知发送方某个分组未被正确接收。                   |
| 窗口、流水线 | 发送方也许被限制仅发送那些序号落在一个限定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等等操作模式的基础上增加。 |



## 面向连接的运算：TCP

### TCP连接

TCP是面向连接的（connection-oriented），在进程间可以开始与另一个进程发送数据之前，这两个进程必须先相互“握手”，即互相发送预备字段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都会初始化与TCP连接相关的许多TCP状态变量。

TCP协议只在端系统中运行，而不会在中间的网络元素（路由器和链路层交换机）中运行，所以网络元素不会维持TCP连接状态。

TCP是全双工服务，也是点对点服务。在三次握手中，前两次不能存在有效载荷，第三次可以。

对于发送方，TCP将数据引导到连接的发送缓存里，发送缓存是三次握手初期设置的缓存之一。TCP可以从缓存中取出并放入报文段中的数据数量受限于**最大报文长度**（Maximum Segment Size，MSS）。MSS通常根据最初确定的最大链路层长度（最大传输单元（MTU））来设置。设置该MSS要保证一个TCP报文段加上TCP/IP首部长度将适合单个链路层帧。

TCP为每块数据配上一个TCP首部，从而形成TCP报文段。这些报文段传输给网络层，网络层将其分别封装进网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的缓存中。

### TCP报文段结构

![TCP packet struction](https://s2.ax1x.com/2019/12/25/lilwDA.png)

当TCP发送大文件时，通常是将该文件划分为长度为MSS的若干块。报文中除了包含源端口、目的端口、校验和等与UDP一致的，还包含部分其他数据：

1. 32比特的序号字段（sequence number）和32比特的确认字段（acknowledgment number）。提供可靠数据传输。
2. 16比特的接收窗口字段，用于流量控制。
3. 4比特的首部长度字段，指示了以32比特的字为单位的TCP首部长度。
4. 可选与变长的可选字段（options），该字段用于发送方与接收方协商最大报文长度（MSS）时，或在高速网络下用作窗口调节因子。
5. 6比特标志字段。ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。RST、SYN和FIN用于连接建立和拆除。当PSH比特被设置时，指示接收方应该立即将数据交付给上层。URG比特用来指示报文段中存放着被发送端实体置为紧急的数据。当紧急数据存在并给出指向紧急数据尾的指针的时候，TCP必须通知接收端的上层实体。（实践中PSH、URG和紧急数据指针并没有使用）。

#### 序号和确认号

TCP把数据看成一个无结构的、有序的字节流，序号建立在传送的字节流之上，而不是建立在传送的报文段的序列上。一个报文段的序列号是该报文段首字节的字节流编号。

TCP是双全工的，因此A向B传送的同时，也许同时接收B的数据（同一条TCP连接）。主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号，即可以看做当前A已经接收到的字节数减1，相当于在告诉B当前A已经确认接收到的数据。（这里说确认接收的数据和已经收到的数据其实不是很准确，因为不一定是从0开始的，而是按照一定方式就初始化开始的）。

同时对于确认号来说，由于TCP是流水线传输，所以对于已经确认接收到的数据来说，可能中间部分没有收到，其前面的分组和后面都收到了，此时确认号是该流中至第一个丢失字节为止的字节，所以TCP被称为提供累积确认（cunulative acknowledgment）。对于失序到达的后面的数据，TCP也不会丢弃，而是缓冲下来。

这里序号和确认号分别对于与发送方和接收方的序号，从初始化序号即可看出来。一条TCP连接的双方均可以随机选择初始序列号(目的是减少将那些人在网络中存在的来自两台主机之间先前已经终止的连接的报文段、误认为是这两台主机之间新建立连接所产生的有效报文段的可能性（可能碰巧与就连接使用相同的端口号）)。例如A初始序号为a，B初始序号为b，此时相当于B已经接收了a-1个数据，A已经接收了b-1个数据，因此A接下来要接收的数据是b，B接下来要接收的数据为a，因此A的确认号为b，B的确认号为a。

如下例：

![seq ack](https://s2.ax1x.com/2019/12/25/liJI9P.png)

上图中A的序号是42，B的序号是79。

注意：对于发送方来说，发送完成后就要等待接收确认，对于接收方来说，接收到之后，即使自己没有要向发送方传递任何数据，也要发送一个确认报文。如上图的第三天报文。

### 往返时间的估计与超时

与rdt3.0一样，TCP也使用超时/重传机制来处理报文段的丢失问题。

#### 估计往返时间

报文段样本RTT（表示为sampleRTT）就是从某报文段被发出到对该报文段被确认收到（收到ACK确认）之间的时间。大多数TCP实现仅在某个时刻做一次sampleRTT测量，而不是为每个发送的报文测量一个sampleRTT。即任意时刻，仅为一个已发送但目前尚未被确认的报文段估计sampleRTT，从而产生一个接近每个RTT的新sampleRTT值。另外，TCP绝不为已被重传的报文段计算sampleRTT。

显然，sampleRTT值是一个随时间变化的值。TCP维持一个sampleRTT均值（称为EstimatedRTT）。一但获取新sampleRTT值就更新EstimatedRTT：
$$
EstimatedRTT = (1-\alpha)*EstimatedRTT + \alpha *SampleRTT
$$
$\alpha$一般取0.125。

EstimatedRTT是一个sampleRTT的加权平均值，且越接近当前的采样，权重越大。

除了定义估算RTT外，测量RTT的变化也是有价值的。RTT偏差DevRTT，用于估算sampleRTT一般会偏离EstimatedRTT的程度：
$$
DevRTT = (1-\beta) * DevRTT + \beta *|sampleRTT - EstimatedRTT|
$$
$\beta$一般取0.25。

#### 设置和管理重传超时间隔

超时间隔应该大于等于EstimatedRTT，否则会造成不必要的重传。超时间隔也不能大太多，否则当报文丢失时，TCP不能很快重传该报文，导致数据传输时延大。于是TCP超时间隔设置为：
$$
TimeoutInterval = EstimatedRTT + 4 * DevRTT
$$

### 可靠数据传输

TCP可靠传输服务确保一个进程从其接收缓存中读出的数据流是无损的、无间隔的、非冗余和按序的数据流。

前面我们在SR中讲到的方法是使每一个报文和一个定时器关联，但定时器花销是是否大的，因此推荐的定时器管理是仅使用单一的定时器。

下面给出TCP发送方高度简化的描述：

```
/假设发送方不受TCP流量和拥塞控制的限制, 来自上层的数据长度小于MSS,且数据传送只在一个方向进行. */

loop(forever)
{
	switch(event)
	
		event: data recieved from application above create TCP segment with sequence number NextSeqNum
			if(timer currently not running)
				strat timer
			pass segment to IP
			NextSeqNum = NextSeqNum+length(data)
			break
		
		event: timer timeout
			retransmit not-yet-acknowledged segment with samllest sequence number
			start timer
			break
		
		event : ACK received, with ACK field value of y
			if(y > SendBase)
				SendBase = y
				if(there are currently any not-yet-acknowledged segments)
					start timer
				break;
		
}
```

其中Nextseqnum被用来记录序号，SendBase是最小为被确认的字节的序号。

#### 超时间隔加倍

如前所述，TCP重传具有最小序号的还没被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设置为先前的两倍，而不是从EstimatedRTT和DevRTT推算出来的值。然而每当定时器在另外两个事件（即收到上层应用的数据和收到ACK）中任意一个启动时，TimeoutInterval由最近的EstimatedRTT值与DevRTT得到。

这种修改提供了一个形式受限的拥塞控制。

#### 快速重传

超时触发重传存在的问题是超时周期可能相对较长。发送方通常可在超时时间之前通过注意所谓的冗余ACK来较好的检测到丢包情况。冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认。

下表总结了TCP接收方ACK的生成策略：

| 事件                                                         | TCP接收方动作                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 具有所期望的按序报文段到达，所有在期望序号以前的数据都已经被确认 | 延迟的ACK，对另一个按序报文段的达到最多等待500ms，如果下一个报文段在这个时间间隔内没有达到，则发送一个ACK |
| 具有所期望序号的按序报文段到达，另一个按序报文段等待ACK传输  | 立即发送单个累积ACK，以确认两个按序报文段。                  |
| 比期望大的失序报文段到达，检测出现间隔                       | 立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端序号） |
| 能部分或完全填充数据间隔的报文段到达                         | 倘若该报文段起始于低端，立即发送ACK                          |

因为发送方经常发送大量报文段，如果一个报文段丢失，就可能引起许多冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK，它把这当成一种指示，说明在这个已被确认过三次的报文段之后的报文段已经丢失。因此，一旦收到3个冗余ACK，TCP就执行快速重传，即在该报文段超时之前重传。

因此，可用下面的代码来替代之前的发送方部分代码：

```
event : ACK received,wite ACK field value of y
	if(y >SendBase)
	{
		SendBase = y
		if(there are currently any not yet acknowledged segments)
			start timer
	}
	else{ /* y == SendBase, 即收到冗余ACK */
		increment number of duplicate ACks received for y
		if(number of duplicate ACKs received for y==3)
		{
			/* TCP fast retransmit */
			resend segment with sequence number y
		}
		
	}
```

TCP的差错恢复机制应该属于GBN和SR的混合体。

### 流量控制

一条TCP连接每一测主机都为该连接设置了接收缓存。TCP提供了流量控制服务（flow-control service）以消除发送方使接收方缓存溢出的可能。该服务与拥塞控制不同。

TCP通过让发送方维护一个称为接收窗口（receive window）的变量来提供流量控制。接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。由于TCP是双全工通信，在连接两端的发送方都各种维护一个接收窗口。假设主机A通过一条TCP连接向主机B发送一个大文件。主机B为该连接分配一个缓存区，用RevBuffer来表示其大小。主机上的应用进程不时地从该缓存中读取数据。同时定义如下变量：

LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。

LastByteRevd：从网络到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。

由于TCP不允许缓存溢出，因此：
$$
LastByteRecv - LastByteRead <= RevBuffer
$$
接收窗口用rwnd表示，则：
$$
rwnd = RevBuffer - [LastByteRevd - LastByteRead]
$$
rwnd是动态变化的。

![rwnd](https://s2.ax1x.com/2019/12/25/liOh9g.png)

主机B通过把当前rwnd值放到它发送给A的报文段接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。开始时，主机B设定rwnd = RevBuffer。为了实现这一点，主机B必须跟踪几个与连接有关的变量。

主机A轮流跟踪两个变量，LastByteSent和LastByteAcked。这两个变量之间的差LastByteSend - LastByteAsked就是主机A发送到连接中但未被确认的数据量。将该数量限制在rwnd内就可以保证主机A不会使主机B的接收缓存溢出。所以：
$$
LastByteSent - LastByteAcked <= rwnd
$$
但该方案存在一个问题。如果B的接收缓存已经满了，使得rwnd = 0。将rend告知A之后，假设主机B上没有任何数据要发送给A。此时，主机B上的应用进程将缓存清空，TCP并不向主机A发送任何带有rwnd的新报文。这样，主机A不可能知道主机B接收空间已经有新空间了，即主机A被阻塞而不能再发送数据。为了解决这个问题，TCP要求，当主机B接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值。

### TCP连接管理

现在来看一条TCP连接是如何建立的，假设运行在主机（客户）上的一个进程想要与另一台主机（服务器）上的进程建立一条连接。客户机会用下面方式与服务器建立连接：

1. 第一步：客户机的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文不包含应用层数据。但是报文段首部中的一个标志位（SYN比特）被置1.因此这个特殊报文段被称为SYN报文段。另外，客户机会随机初始化一个初始序号（client_isn），并将该编号置于起始的TCP SYN报文段的序号段中。该报文被封装在一个IP数据报中，并发送给服务器。
2. 第二步：一旦一个包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该酷虎就TCP发送允许连接的报文段。（在完成三次握手的第三步之前分配资源，使得TCP易于受到被称为SYN洪泛的拒绝服务攻击）。这个运行连接的报文段也不包含应用层数据。但是该报文段首部包含3个重要信息。首先SYN比特被置1，其次该TCP报文段首部的确认号字段被设置为client_isn+1。最后，服务器选择自己的初始序号（server_isn)，并将其放置到TCP报文段首部的序号字段中。该报文被称为SYNACK报文段。
3. 在收到SYNACK报文段后，客户机也要为该连接分配缓存和变量。客户机向服务器发送另一个报文段，最后一个报文段对服务器的允许连接的报文段进行了确认（将值server_isn+1放置到TCP报文段首部的确认字段中来完成此项工作）。因为连接已经建立，该SYN比特被置为0。该三次握手的第三阶段可以在报文段负载中携带客户到服务器的数据。

一旦建立连接后，就可以互相传输报文了，此时SYN都是0。

![TCP three-way](https://s2.ax1x.com/2019/12/25/lF9o79.png)

下面我们再来看TCP如何终止连接。参与连接的任何一个都可以终止该连接。当连接结束后，主机中的资源将被释放。假如某个主机打算关闭连接，如下图。客户应用进程发出一个关闭连接命令。这会使客户TCP向服务器进程发送一个特殊的TCP报文段，该报文段首部FIN标志位被设置为1。当服务器接收到该该报文段后，就向发送方返回一个确认报文段。然后服务器就发送自己的终止报文，其FIN被置为1.最后，该客户机对这个服务器的终止报文进行确认。此时，在两台主机上用于该连接的所以资源都被释放了。

![TCP fin](https://s2.ax1x.com/2019/12/25/lFPQVH.png)

下图展示了客户TCP经典的TCP状态序列：

![TCP state](https://s2.ax1x.com/2019/12/25/lFPfZ4.png)

其中在TIME_WAIT等待状态时，确定ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文经过等待后，连接正式关闭，客户机所以资源包括端口号被释放。（等待时间取决于实现）

下图为服务器端TCP经历的典型的TCP状态序列：

![TCP state](https://s2.ax1x.com/2019/12/25/lFitYR.png)

## 拥塞控制原理

### 拥塞原因与代价

#### 情况1：两个发送方和一台无穷大缓存的路由器

最简单的拥塞情况：两台主机（A和B）都有一条连接，且这两条连接共享源与目的地之间的单跳路由。此时限制只有共享式输出链路的容量。当两个主机传输的总速度超过链路的总容量，就会导致拥塞。

#### 情况2：两个发送方和一台具有有限缓存的路由器

此时拥塞则有两部分组成，第一部分和情况1一样，两台主机所传输速度和，还有一个问题则是在有限缓存的路由器上存在丢包。丢包会加大两台主机传输速率，但造成更严重的拥塞和丢包。

#### 情况3:4个发送方和具有有限缓存的多台路由器及多跳路径

![state 4](https://s2.ax1x.com/2019/12/26/lkhPNd.png)

此时对于每一条传输路径来说，都经历两段。每段都有两条路径共享，而且共享段是其中一条路径的第一段，另一条路径的第二段。此时，往往作为第一段的那条路径会被优先满足，挤占掉作为第二段路径的那条路径。而被满足的那条路径到它的第二段路径时，又会被另一条路径挤占掉（因为在它的第二段里还存一个作为第一段的路径）。最终将会导致所以路径全部拥塞。

### 拥塞控制方法

拥塞控制主要有两种方法：

1. 端到端拥塞控制：网络中存在拥塞，端系统必须通过对网络进行观察来推断。
2. 网络辅助的拥塞控制：在网络辅助的拥塞控制中，网络层构建（即路由器）向发送方提供关于网络中阻塞状态的显示反馈信息。

## TCP拥塞控制

TCP所采取的方法是让每一个发送方根据所感知到的网络拥塞程度来限定其向连接发送的流量的速率。

首先来看TCP如何限制向其连接发送流量的。运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞控制窗口（cwnd），它对一个TCP发送方能够向网络中发送流量的速率进行了限制，特别是，一个发送方中未被确认的数据量不会超过cwnd和rwnd中的最小值：
$$
LastByteSent - LastByteAcked <= min\{cwnd, rwnd\}
$$
为了只关注与拥塞控制，下面的讨论假设rwnd足够大，我们可以忽略该值。因此，发送方发送速率大概是cwnd/RTT 字节/秒。通过调节cwnd值，我们可以调节其发送速率。

下面考虑TCP发送方如何感知它与目的地之间的路径上出现了拥塞。我们将一个TCP发送方的“丢包事件”定义为：要么出现超时，要么收到来自接收方的3个冗余ACK。

接下来考虑网络没有拥塞的情况，即没有出现丢包时间的情况。此时，TCP的发送方将收到对于以前未确认报文段的确认。TCP将这些确认到达作为一切正常的指示，并用来增加窗口的长度。因为TCP使用确认来触发（或计时）增大它的拥塞窗口长度，TCP被说成是自计时的。

TCP对各个事件的指导性原则是：

1. 一个丢失的报文段意味着拥塞，因此丢失报文段时应该降低TCP发送方的速率。一个超时事件或者四个确认（一个初始ACK和三个冗余ACK）被解释为“丢包事件”的一种隐含的指示。
2. 一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。
3. 带宽探测：给定ACK指示源到目的地路径无拥塞，而丢包事件指示路径拥塞，TCP调节其传输速率的策略是增加其速率以响应到达的ACK，除非出现丢包事件，此时才减小传输速度。因为，为探测拥塞开始的速率，TCP发送方增加它的传输速率，从该速率后退，进而再次探测，可靠拥塞开始速率是否发送了变化。

TCP拥塞控制算法包括三部分：慢启动；拥塞避免；快速恢复。

### 慢启动

当一条TCP连接开始时，cwnd通常设置为一个MSS的较小值，TCP希望迅速找到可用带宽的数量。在慢启动状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。如下图所示，每过一个RTT，发送速率就翻倍，TCP发送速率起始慢，但在慢启动阶段以指数增长，

![慢启动](https://s2.ax1x.com/2019/12/26/lkbHEV.png)

慢启动结束的条件有多种。首先，如果存在一个由超时指示的丢包（即拥塞），TCP发送方将cwnd设置为1并重新开始慢启动过程。它还将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2，即当检测到拥塞时，将ssthresh置为拥塞窗口值的一半。慢启动的第二种方式是直接与ssthresh值相关联。因为当检测到拥塞时ssthresh设为cwnd的一半，当cwnd等于ssthresh值时，结束慢启动并将TCP转移到拥塞避免模式。最后一种方式是，如果检测到3个冗余ACK，TCP执行快速重传并进入快速恢复状态。

### 拥塞避免

一旦进入拥塞避免，cwnd值大约是上次遇到拥塞时值的一半。此时采取比较保守的方法，每个RTT只将cwnd值加一（慢启动成倍）。通用方法是对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS（MSS/cwnd）字节。例如，MSS是1460字节，cwnd是14600字节，则在一个RTT内发送10个报文。每个到达ACK增加1/10MSS的拥塞长度，这样在收到10个报文后，拥塞窗口就增加了一个MSS。

结束拥塞避免的线性增长时机为：当出现超时时，TCP的拥塞避免算法行为与慢启动情况一致，cwnd被设置为1MSS。当出现3个冗余ACK事件时，网络继续从发送方向接收方交付报文段，因此TCP对这种丢包事件的行为，相比于超时指示的丢包应当不那么剧烈，此时TCP将cwnd的值减半，并且将ssthresh的值记录为cwnd的值的一半。接下来进入快速恢复状态。

### 快速恢复

在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP进入拥塞避免状态。如果出现超时事件，快速恢复再执行如图在慢启动和拥塞避免中相同的动作，迁移到慢启动状态。

下图展示了TCP的FSM：

![TCP FSM](https://s2.ax1x.com/2019/12/26/lkO0c4.png)

TCP拥塞控制常常被错误加性增、乘性减（AIMD）。

TCP吞吐量公式，该公式作为丢包率L、往返时间RTT和最大报文段长度MSS的函数：
$$
一条连接的平均吞吐量 = \frac{1.22*MSS}{RTT\sqrt{L}}
$$



# 第四章 网络层：数据平面

网络层能够被分解为两个相互作用的部分，即数据平面和控制平面。本章主要讨论数据平面，即网络层中每台路由器的功能，该数据平面功能决定到达路由器输入之一的数据报（网络分组）如何转发到该路由器的输出链路之一。下一章，我们将讨论网络层的控制平面功能，即网络范围的逻辑，该控制平面功能控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。

## 网络层概述

### 转发和路由选择：数据平面和控制平面

网络层的作用是将分组从一台发送主机移动到一台接收主机。为此，需要使用两种重要的网络层功能：

1. 转发：当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。转发是在数据平面中实现的唯一功能。
2. 路由选择：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法（routing algorithm）。

转发是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。路由选择是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程，通常由软件来实现。

每台网络路由器有一个关键元素是它的转发表（forwarding table）。路由器检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引，通过这种方式来转发分组。这些值对应存储在转发表项中的值，指出了该分组将被转发的路由器的输出链路接口。如下图：

![routing](https://s2.ax1x.com/2020/01/11/lIiPSI.png)

#### 控制平面：传统方法

路由选择算法决定了插入该路由器转发表中的内容。在一台路由器中的路由选择算法与在其他路由器中的路由选择算法通信，以计算出它的转发表的值。路由器中存在所以转发表可以由人工配置。

#### 控制平面：SDN方法

下图展示了从路由器物理上分离的另一种方法，远程控制器计算和分发转发表以供每台路由器所使用。

![SDN](https://s2.ax1x.com/2020/01/11/lIF7Kx.png)

上图中，控制平面路由选择功能与物理的路由器是分离的，即路由选择设备仅执行转发，而远程控制器计算并分发转发表。

### 网络服务模型

网络服务模型（network service model）定义了分组在发送与接收端系统之间的端到端运输特性。网络层提供的服务可能包括：

1. 确保交付。服务确保分组将最终到达目的地。
2. 具有时延上限的确保交付，确保交付，且确保延时时间。
3. 有序分组交付。
4. 确保最小带宽。
5. 安全性。

因特网的网络层提供了单一的服务，称为尽力而为服务。尽力而为的服务是根本不提供服务的委婉说法。

## 路由器工作原理

下图展示了路由器体系结构总体视图，总共包含四部分：

![routing struction](https://s2.ax1x.com/2020/01/11/lIAUhQ.png)

1. 输入端口：输入端口（input port）执行几项重要功能。其在路由器中执行终结入物理链路的物理层功能。显示在上图输入端口部分最左侧方框与输出端口部分最右侧的方框中。其还要与位于入链路远端的数据链路层交互来数据链路层功能，这显示在输入与输出端口部分中间的方框中。在输入端口还要执行查找功能，这显示在输入端口最右侧的方框中，正是在这里，通过查询转发表决定路由器的输出端口，到达的分组通过路由器的交换结构转发到输出端口。控制分组（如携带路由器选择协议信息的分组）从输入端口转发到路由器选择处理器。这里“端口”指的是路由器物理输入输出接口。
2. 交换结构：交换结构将路由器的输入端口连接到它的输出端口。这种交换结构包含在路由器中，即其为一个网络路由器中的网络。
3. 输出端口：输出端口存储从交换结构接收到的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。
4. 路由选择处理器：路由器选择处理器执行控制平面功能。在传统的路由器中，它执行路由选择协议，维护路由器选择表与关联链路状态信息，并为该了一起去计算转发表。在SDN路由器中，路由选择处理器（在其他活动中）负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项。

路由器的输入端口、输出端口和交换结构几乎总是用硬件实现。路由器的控制功能包括执行路由选择协议、对上线或下线的连接链路进行响应、与远程控制器通信（在SDN中）和执行管理功能。这些控制平面的功能通常用软件实现并在路由选择器中执行。

### 输入端口处理和基于目的的转发

![输入端口](https://s2.ax1x.com/2020/01/12/loZTdx.png)

上图具体展示了输入端口的结构。线路端接功能与链路层处理实现了各个输入链路的物理层和链路层，输入端口执行的查找，使用了转发表来查找输出端口。转发表是由路由选择处理器计算和更新的，或者转发表接收来自远程SDN控制器的内容。转发表从路由选择处理器经过独立总线复制到线路卡。该线路在图4-4的从路由选择处理器到输入线路卡的虚线所示。使用在输入端口的影子副本，转发决策能够在每个输入端口本地做出，无需基于每个分组调用集中式路由选择处理器，因此避免了集中式处理的瓶颈。

对于转发表选路的规模问题，我们可以使用前缀。举例为：

| 目的地址范围                                                 | 链路接口 |
| ------------------------------------------------------------ | -------- |
| 11001000 00010111 00010000 00000000到11001000 00010111 00010111 11111111 | 0        |
| 11001000 00010111 00011000 00000000到11001000 00010111 00011000 11111111 | 1        |
| 11001000 00010111 00011001 00000000到11001000 00010111 00011111 11111111 | 2        |
| 其他                                                         | 3        |

此时我们只需使用四个转发表项：

| 前缀匹配                   | 链路接口 |
| -------------------------- | -------- |
| 11001000 00010111 00010    | 0        |
| 11001000 00010111 00011000 | 1        |
| 11001000 00010111 00011    | 2        |
| 其他                       | 3        |

在使用匹配时，当有多个匹配项时，路由器使用最长前缀匹配规则：即在该表中。寻找最长的匹配项。输入端口处理查找操作外，还要处理指数三个动作：1）必须出现物理层和链路层处理；2）必须检查分组的版本号、校验和以及寿命字段，并重写后两个字段；3）必须更新用于网络管理的计数器（如接收到的IP数据报数目）。

### 交换

交换可以用许多方式完成，如下图：

![rechange](https://s2.ax1x.com/2020/01/12/loKnvF.png)

1. 经内存交换：输入输出端口之间的交换在CPU（路由选择处理器）的直接控制下完成，输入输出端口的功能就像传统操作系统的I/O设备一样。
2. 经总线交换：输入端口经一根共享总线将分组直接传输到输出端口，不需要路由选择处理器的干预。通常按下面方式完成任务：让输入端口为分组预先计划一个交换机内部标签（首部），指示本地输出端口，使分组在总线上传送和传输到输出端口。该分组能够由所以输出端口收到，但只有与该标签匹配的端口才能保存该分组。然后标签在输出端口被除去。由于仅用于交换机内部来跨越总线，因此当多个分组同时达到时，除了一个分组外，其他分组必须等待。
3. 经互联网络交换：纵横式交换机是一种由2N条总线组成的互联网路，它连接N个输入端口和N个输出端口。每条垂直的总线在交叉点与每条水平的总线交叉，交叉点通过交换结构控制器能够在任何时候开启或关闭。当分组到达A要转发到Y，交换机控制器关闭总线A和Y交叉部位的交叉点，然后端口A在其总线上发送该分组，该分组仅由总线Y接收纵横式交换机非阻塞的，即只要没有其他分组当前被转发到该输出端口，转发到该输出端口的分组就不会被到达输出端口的分组阻塞。

### 输出端口处理

![output](https://s2.ax1x.com/2020/01/12/lo1CR0.png)

### 何时出现排队

#### 输入排队

如果交换结构不能快得使所有到达分组无时延地通过它传送，此时就会在输入端口出现分组排队，由于到达的分组必须加入输入端口队列中，以等待通过交换结构传送到输出端口。

#### 输出排队

当输入端口速度很快且传送的分组很多，交换结构的速度也很快，此时，同一时刻到达输出端口的分组将会有很多，而输出端口每个时刻只能传送一个分组，在这种情况下就会出现输出排队。

当没有足够的内存来缓存一个分组时，就必须做出决定：要么丢弃到达的分组（弃尾策略），要么删除一个或多个已排队的分组为新的分组腾出空间。

路由器需要的缓存，经验方法是缓存数量应该当用平均往返时延（RTT）乘以链路的容量。

### 分组调度

分组调度考察的是被排队的分组如何经输出链路传输的问题。

#### 先进先出

FIFO（First-In-First-Out）按照分组到达输出链路队列的相同次序来选择分组在链路上传输。下图展示了FIFO队列：

![FIFO](https://s2.ax1x.com/2020/01/12/lo8r5j.png)

#### 优先权排队

在优先权排队中，到达输出链路的分组被分类放入输出队列中的优先权类。每个优先权类通常有自己的队列，在选择一个传输时，将从队列为非空的最高优先权类中传输一个分组。在同一优先权类的分组中，选择通常以FIFO的方式，

#### 循环和加权公平排队

在循环排队规则中，分组像使用优先权排队那样被分类。然而，不同类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。

加权公平排队（Weighted Fair Queuing，WFQ）中，到达的分组被分类并在合适的每个类的等待区域排队。与循环调度一样，WFQ调度器也以循环的方式为各个类提供服务。WFQ与循环排队的不同之处在于，每个类在任何时间间隔内可能收到不同数量的服务。即按照分组权值来决定每个时间的服务对象。

## 网际协议：IPv4、寻址、IPv6及其他

### IPv4数据报格式

![IPv4](https://s2.ax1x.com/2020/01/12/loLOcF.png)

IPv4数据报中关键字段如下：

1. 版本号：规定了数据报IP协议版本。通过查看版本号，路由器能够确定如何解释IP数据报的剩下部分。
2. 首部长度：IPv4包含可变数量的选项，因此使用4比特来确定IP数据报载荷实际开始的地方。（大多数IP数据报不包含选项，所以一般IP数据报具有20字节首部）
3. 服务类型：服务类型（TOS）用于使不同类型数据报能够相互区分开。
4. 数据报长度：IP数据报的总长度（首部加数据），以字节计该字段为16比特，所以IP数据报理论长度不超过65535字节。
5. 标识、标志、片偏移：这三个字段与IP分片有关，下一节具体讨论。
6. 寿命：寿命（TTL）字段用来确保数据报不会永远（如由于长时间的路由选择环路）在网络中循环。每当一台路由器处理数据报时，该字段的值减一。当TTL为0则丢弃。
7. 协议：该字段在IP数据报到达目的地时使用。该字段指示了IP数据报部分应该交给哪个特定的运输层协议。
8. 首部校验和：用于帮助路由器检测收到的IP数据报的比特错误。计算方式为：首部的每两个字节作为一个数，用反码算数对这些数求和。（只对首部进行求和）。
9. 源和目的IP地址。
10. 选项：用于扩展IP首部。很少使用。
11. 数据（有效载荷）：运输层报文或者其他类型数据，如ICMP报文。

### IPv4数据报分片

并不是所有链路层协议都能承载相同长度的网络层分组。一个链路层帧能够承载的最大数据量叫做最大传输单元（MTU）。MTU严格限制着IP数据报的长度。发送方与目的地的路径上的每段链路可能使用不同的链路层协议，且每种协议可能具有不同的MTU。

将过大的IP数据分片成两个或多个较小的IP数据报，用单独的链路层帧封装这些数据报，然后通过输出链路发送这些帧。这些较小的数据报称为片，该过程即为数据报分片。

片在到达目的地的运输层以前需要重新组装。运输层协议都希望从网络层收到完整的、未分片的报文。IPv4对数据报的重新组装工作放到端系统中，而不是网络路由器中。

为了让目的主机执行重新组装任务，IPv4将标识、标志和片偏移字段放在IP数据报首部中。当生成一个数据报时，发送主机为该数据包设置源和目的地址的同时贴上标识号。发送主机通常将它发送的每一个数据报的标识号加1.当路由器对一个数据报分片时，形成的每个数据报具有初始数据报的源和目的地址与标识号。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据是同一个较大的数据报的。为了让目的主机绝对相信它已收到了初始数据报的最后一个片，最后一个片的标志比特被设置为0，而所有其他片的标志比特被设置为1。为了让目的主机确定是否丢失了一个片（且能够按正确顺序重新组装片），使用偏移字段指定该片应该放在初始IP数据报的哪个位置。

### IPv4编址

一台主机通常只有一条链路连接到网络，主机与物理链路之间的边界叫做接口（interface）。路由器与它的任意一条链路之间的边界也叫作接口，因此一台路由器有多个接口，每个接口有其链路。每台路由器与路由器都能够发送和接收IP数据报，IP要求每台主机和路由器接口拥有自己的IP地址。因此，<font color =red>从技术上将，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</font>

每个IP地址长度为32比特，地址常按点分十进制记法书写，每个字节用它的十进制形式书写，各字节间以句点隔开。因特网中的每台主机和路由器上的每个接口都必须有一个全球唯一的IP地址（NAT后面的接口除外）。一个接口的IP地址的一部分需要由其连接的子网决定。

![IP](https://s2.ax1x.com/2020/01/13/l787zn.png)

上图提供了一个IP编址与接口的例子。图中，左侧三台主机和他们相连的路由器接口都有一个形如233.1.1.xxx的IP地址，即，他们的最左侧24比特是一样的，这四个接口也通过一个并不包含路由器的网络互联起来。

互联这3个主机接口与1个路由器接口的网络形成一个子网（subnet）。IP编址为这个子网分配一个地址233.1.1.0/24，其中/24记法，有时称为子网掩码，指示32比特中最左侧24比特定义了子网地址。因此子网233.1.1.0/24由三个主机接口（233.1.1.1，233.1.1.2，233.1.1.3）和一个路由器接口233.1.1.4组成。任何连接到233.1.1.0/24网络的主机都要求其他地址具有233.1.1.xxx的形式。下图展示了另外两个网络：

![sebnet](https://s2.ax1x.com/2020/01/13/l78TRs.png)

一个子网的IP定义并不局限于连接多台主机到一个路由器接口的以太网段。下图中，除了主机与路由器接口相连的三个子网外，每两个相互连接的路由器端口之间构成子网。

![subnet](https://s2.ax1x.com/2020/01/13/l78oGj.png)

为了确认子网，分开主机和路由器的每个接口，产生一个隔离的网络岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫做一个子网。

因特网的地址分配策略被称为无类别域间路由选择（Classless Interdomain Routing，CIDR）。当使用子网寻址时，32比特被划分为两部分，且具有点分十进制形式a.b.c.d/x，其中x指示了地址的第一部分比特数。

形式a.b.c.d/x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的前缀（prefix）。一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。此时，组织内部的设备的IP地址将共享共同的前缀。

一个地址的剩余32-x比特可认为是用于区分该组织内部的设备的，其中所有设备具有相同的网络前缀。

IP广播地址为255.255.255.255,。当一台主机发出一个目的地址是255.255.255.255的数据报时，该报文会交付给同一网络中的所有主机。

#### 获取一块地址

因特网名字和编号分配机构（ICANN）管理IP地址的分配。ISP向ICANN获取一块较大的地址。ISP访问的组织向ISP申请获取ISP拥有的地址的一部分地址。

#### 获取主机地址：动态主机配置协议

动态主机配置协议（Dynamic Host Configuration，DHCP）允许主机自动获取（被分配）一个IP地址。网络管理员能够配置DHCP，以使得某给定主机每次与网络连接是能够得到一个相同的IP地址，或者某主机被分配一个临时的IP地址。DHCP还允许一台主机得知其他信息，例如它的子网掩码、第一跳路由器地址（默认网管）与它的本地DNS服务器地址。

DHCP被称为即插即用协议或零配置协议。DHCP是一个客户-服务器协议。客户通常是新到达的主机，它要获得包括自身使用的IP地址在内的网络配置信息。在最简单场合下，每个子网都将具有一台DHCP服务器。如果在某个子网中没有服务器，则需要一个DHCP中继代理（通常是一台服务器），这个代理知道用于该网络的DHCP服务器的地址。

![DHCP](https://s2.ax1x.com/2020/01/14/lbf4D1.png)

对于一台新到达的主机而言，DHCP协议是一个4个步骤的过程：

1. DHCP服务器发现：一台新到达的主机的首要任务是发现一个要与其交互的DHCP服务器。通过使用DHCP发现报文俩完成，客户在UDP分组中向端口67发送该发现报文。该UDP分组封装在一个IP数据包中，使用广播目的地址255.255.255.255并且使用“本主机”源IP地址0.0.0.0。DHCP客户将该IP数据报传递给链路层，链路层然后将该帧广播到所以与该子网连接的节点。
2. DHCP服务器提供：DHCP服务器收到一个DHCP发现报文时，用DHCP提供报文向客户做出响应，该报文向该子网的所有节点广播，任然使用IP广播地址255.255.255.255.子网可能存在几个DHCP服务器，客户可能会发现它处于能在几个提供者之间进行选择的优越位置。每台服务器提供的包含有收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码已经IP地址租用期，即IP地址有效的时间量。
3. DHCP请求：新到达的客户从一个或多个服务器提供中选择一个，并向选中的服务器提供DHCP请求报文进行响应，回显配置参数。
4. DHCP ACK：服务器用DHCP ACK报文对DHCP请求报文进行响应，证实所要求的参数。

![DHCP](https://s2.ax1x.com/2020/01/14/lbHMwj.png)

DHCP提供了一种机制以允许客户更新它对一个IP地址的租用。

### 网络地址转换

![NAT](https://s2.ax1x.com/2020/01/14/lbq5SP.png)

上图展示了一台网络地址转换（Network Address Translation，NAT）使能路由器运行情况。在家庭网络内的编址就像我们上面看到的完全一样，其中四个接口都具有相同的网络地址10.0.0/24。地址空间10.0.0/24是在[RFC 1918]中保留的三部分IP地址空间之一，这些地址用于上图中的家庭网络等专用网络或具有专用地址的地域。10.0.0/24仅在给定的网络中才有意义。

NAT路由器对外界的行为就如同一个具有单一IP地址的单一设备。如上图，所有离开家庭路由器流向更大因特网的报文都用于一个源IP地址138.76.29.7，且所有进入家庭的报文都拥有同一个目的IP地址138.76.29.7。NAT使能路由器对外界隐藏了家庭网络的细节。

NAT路由器上包含一张NAT转换表，并且在表项中包含了端口号及其IP地址。举例来说。一个用户在家庭网络主机10.0.0.1，请求IP地址为128.119.40.186的某台Web服务器（端口号为80）上的一个Web页面。主机10.0.0.1为其指派了源端口为3345并将数据发送到LAN。NAT路由器接收到该数据报，为该数据报生成一个新的端口号5001.当生成一个新端口号时，NAT路由器可以选择任意一个当前未在NAT转换表中端口号。路由器中的NAT也在它的NAT转换表中增加一表项。Web服务器并不知道到达的包含HTTP请求的数据报已经被NAT路由器进行了改装，它会返回一个响应报文，其目的地址是NAT路由器的IP地址，端口号是5001。当该报文到达NAT路由器时，路由器使用目的IP地址与目的端口号从NAT转换表中检索出家庭网络浏览器使用的适当IP地址和目的端口号。于是重写该数据报的目的IP地址与目的端口号，并向家庭网络发送报文。

### IPv6

#### IPv6数据报格式

![IPv6](https://s2.ax1x.com/2020/01/14/lq53dI.png)

IPv6中重要的变化为：

1. 扩大地址容量：IP地址长度从32比特增加128比特。IPv6还引入了任播地址的新型地址，这种地址可以使数据报交付给一组主机的任意一个。
2. 简化高效的40字节首部：舍弃了选项。
3. 流标签：IPv6存在一个流标签。该字段可用于“给属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流”。

下面详细介绍各个字段：

1. 版本：IP版本号。
2. 流量类型：与IPv4看到的服务类型含义相似。
3. 流标签：标识一条数据报的流。
4. 有效载荷长度：数据报中跟在40字节首部后面的字节数量。
5. 下一个首部：数据报中的内容一个交给哪个协议。使用与IPv4中协议字段相同的值。
6. 跳限制：转发数据报的每台路由器将对该字段值减一。跳限制达到0则丢弃该数据报。
7. 原地址与目的地址。
8. 数据。

与IPv4相比，部分字段和操作已经不存在了：

1. 分片/重新组装：IPv6不允许分片和重新组装。当数据报太大时将会被丢弃，同时向源主机发送一个分组太大的ICMP差错报文。
2. 首部校验和：删除了首部校验和。
3. 选项：选项不再是首部的一部分，而是可能出现在IPv6首部中由“下一个首部”指出的位置上。

#### IPv4到IPv6的迁移

IPv4到IPv6迁移的方法是建隧道（tunneling）。建隧道的基本思想是：假定两个IPv6节点要使用IPv6数据报进行交互，但它们中间由IPv4路由器互联。我们将两台IPv6路由器之间的IPv4路由器的集合称为一个隧道，借助隧道，在隧道发送端的IPv6节点可将整个IPv6数据报放到一个IPv4数据报的数据字段中。于是，该IPv4数据报的地址设置为指向隧道接收端的IPv6节点，再发送给隧道的第一个节点。隧道接收端的IPv6节点最终收到IPv4数据报，并从中获取IPv6数据报，然后再为IPv6提供路由。

![IPv4 to IPv6](https://s2.ax1x.com/2020/01/15/lOFFbj.png)

## 通用转发和SDN

基于目的的转发的特征总结为两个步骤：查找目的IP地址（匹配），然后将分组发送到有特定输出端口的交换结构（动作）。现在考虑一种更有意义的通用“匹配加动作”范式，其中能够对协议栈的多个首部字段进行匹配，这些首部字段是与不同层次的不同协议相关联的。动作能够包括：将分组转发到一个或多个输出端口（如基于目的的转发），跨域多个通向服务的离开接口进行负载均衡分组（如负载均衡），重写首部值（如NAT），有意识地阻挡/丢弃某个分组（如防火墙），为进一步处理和动作而向某个特定服务器发送一个分组（如DPI），等等。

在通用转发中，一张匹配加动作表将基于目的的转发表一般化了。展示在下图的张设备是分组交换机：

![通用转发](https://s2.ax1x.com/2020/01/15/lOeFqU.png)

上图展示了位于每台分组交换机中的一张转发加动作表，该表由远程控制器计算、安装和更新。虽然在各个分组交换机中的控制组件可以相互作用，但实践中通用匹配加动作能力是通过计算、安装和更新这些表的远程控制器实现的。

后面的讨论基于OpenFlow，匹配加动作转发表在OpenFlow中称为流表（flow table），它的每个表项包括：

1. 首部字段值的集合：入分组将与之匹配，匹配不上流表项的分组将被丢弃或发送到远程控制器做更多处理。实践中，一个流表可以由多个流表实现。
2. 计数器集合：当分组与流表匹配时更新计数器。这些计数器可以包括已经与该表项匹配的分组数量，以及自该表项上次更新以来的时间。
3. 当分组匹配流表项时所采取的动作集合：动作与上文所述类似，存在不同的动作。

流表本质上是一个API，通过这种抽象每台分组交换机的行为能够被编程。

### 匹配

![OpenFlow](https://s2.ax1x.com/2020/01/15/lXtcjS.png)

上图展示了11个分组首部字段和入端口ID，该ID能够被OpenFlow 1.0中的匹配加动作规则所匹配。OpenFlow的匹配抽象运行对来自三个层次的协议首部所选择的字段进行匹配（勇敢的违反了分层原则）。

入端口是指分组交换机上接收分组的输入端口。

流表项也可以有通配符。如流表中IP地址128.199.\*.\*将匹配其地址前16比特为128.119的任何数据报所对应的地址字段。每个流表项也具有相应的优先权。如果勇敢分组匹配多个流表项，选定的匹配和对应的动作将是其中最高优先权的那个。

并非一个IP的所有字段都能被匹配，如OpenFlow中不能匹配TTL字段。

### 动作

每个流表项有零个或多个动作列表，动作决定了应用于与流表项匹配的分组的处理。如果有多个动作，它们以在表中规定的次序执行。

比较重要的动作有：

1. 转发：一个入分组可以转发到一个特定的物理输出端口，广播到所以端口，或通过所选端口集合进行多播。
2. 丢弃：没有任何动作的流表项表面某个匹配的分组应该被丢弃。
3. 修改字段：在分组被转发到所选的输出端口之前，分组首部10个字段中的值可以重写。

### 匹配加动作操作中的OpenFlow例子

![ex](https://s2.ax1x.com/2020/01/15/lXUlz6.png)

网络结构如上图。

#### 第一个例子：简单转发

转发行为是：来自h5或h6发往h3或h4的分组从s3转发到s1，然后从s1转发到s2。在路由器中的流表项是：

| 分组交换机 | 匹配                                                   | 动作       |
| ---------- | ------------------------------------------------------ | ---------- |
| s1         | Ingress Port = 1；IP Src=10.3.\*.\*；IP Dst=10.2.\*.\* | Forward(4) |
| s3         | Ingress Port = 1；IP Src=10.3.\*.\*；IP Dst=10.2.\*.\* | Forward(3) |
| s2         | Ingress Port = 2; IP Dst = 10.2.0.3                    | Forward(3) |
| s2         | Ingress Port = 2; IP Dst = 10.2.0.4                    | Forward(4) |

#### 第二个例子：负载均衡

考虑一个负载均衡的场景：来自h3发往10.1.\*.\*的数据报经过s1和s2之间的直接链路转发，于此同时来自h4发往10.1.\*.\*的数据报经过s2和s3（再从s3到s1）之间的链路转发，此时s2中的流表项将是：

| 匹配                               | 动作       |
| ---------------------------------- | ---------- |
| Ingress Port = 3;IP Dst=10.1.\*.\* | Forward(2) |
| Ingress Port = ;IP Dst=10.1.\*.\*  | Forward(1) |

#### 第三个例子：充当防火墙

s2仅希望接收来自与s3相连的主机所发送的流量：

| 匹配                              | 动作       |
| --------------------------------- | ---------- |
| IP Src=10.3.\*.\*;IP Dst=10.2.0.3 | Forward(3) |
| IP Src=10.3.\*.\*;IP Dst=10.2.0.4 | Forward(4) |

如果s2的流表中没有其他表项，则仅有来自10.3.\*.\*的流量将被转发到与s2相连的主机。

# 第五章 网络层：控制平面

## 概述

对于转发表（基于目的的转发）和流表（通用转发）的计算、维护和安装有两种可能的方法：

1. 每路由器控制：每台路由器都包含转发和路由选择功能。每台路由器都有一个路由选择组件，用于与其他路由器中的路由器中的路由选择组件通信，以计算其转发值。接下来将要讨论的OSPF和BGP协议都是基于这种方式的。

   ![每路由器控制](https://s2.ax1x.com/2020/01/17/lzehUf.png)

2. 逻辑集中式控制：逻辑集中式控制器计算并分发转发表以供每台路由器使用的情况。通用的“匹配加动作”抽象允许执行传统的IP转发以及其他功能（负载共享、防火墙功能和NAT）的丰富集合，这些功能先是在单独的中间盒中实现的。

   ![逻辑集中式控制](https://s2.ax1x.com/2020/01/17/lzefVP.png)

该控制器经一种定义良好的协议与每台路由器中的一个控制代理（CA）进行交互，以配置和管理该路由器的转发表。CA一般具有最少的功能，任务是与控制器通信并且按控制器命令行事。

## 路由选择算法

可以用图来形式化描述路由选择问题。图G = （N，E）是一个N个节点和E条边的集合，其中每条边是取自N的一对节点。

![Graph](https://s2.ax1x.com/2020/01/17/lznklQ.png)

一条边还有一个值表示其开销，通常，一条边的开销可反应出对应链路的物理长度，它的链路速度、或与该链路相关的金钱上的开销。用c（x，y）表示节点x和y的开销。对应无向图c（x，y）= c（y，x）。点对（x，y）不属于E，则c（x，y）为无穷大。（x，y）属于E则x，y互为邻居。

路由选择算法分为集中式和分散式：

1. 集中式路由选择算法：用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。
2. 分布式路由选择算法：路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网路链路开销的完整信息。每个节点仅有与其直接相连链路的开销知识即可开始工作。

路由器第二种分类是根据算法是静态的还是动态的进行分类。静态选路算法中，路由随时间变化缓慢，通常由人工进行调整。动态路由选择算法随着网络流量负载或拓扑发送变换而改变路由选择路径。

路由选择算法的第三种分类方式是根据是否为负载敏感还是迟钝进行分类。负载敏感算法中，链路开销会动态地变化以反应出底层链路的当前阻塞水平。负载迟钝的算法中，链路的开销不明确反应当前的阻塞水平。

### 链路状态路由选择算法

链路状态中，网络拓扑和所有的链路开销都是已知的，即可以作为LS算法的输入。

下面给出的链路状态路由选择算法叫做Dijkstra算法。还有一个密切相关的算法是Prim算法。Dijkstra算法计算从某节点（源节点u）到网络中所有其他节点的最低开销路径。Dijkstra算法是迭代算法，其性质是经算法的K次迭代后，可知道到K个目的节点的最低开销路径。我们定义下列记号：

1. D(v):到算法的本次迭代，从源节点得到目的节点v的最低路径的开销。
2. p(v):从源到v沿着当前最低开销路径的前一节点（v的邻居）。
3. N':节点子集；如果从源到v的最低开销路径已确定，v在N'中。

源节点u的链路状态（LS）算法

```
Initialization
N' = {u}
for all nodes v
	if v is a neighbor of u
		then D(v) = c(u,v)
	else D(v) = 无穷

Loop
	find w not in N' such that D(w) is a minimum
	add w to N'
	update D(v) for each neighbor v of w and not in N':
		D(v) = min(D(v), D(w)+c(w,v))
	/* new cost to v is either old cost to v or known least path cost to w plus cost w to v*/
```

当LS算法终止时，对于每个节点，我们都能得到从源节点沿着它的最低开销路径的前一个节点。对于每个前一节点，他们又有它的前一节点，以此方式构建从源节点到所有目的节点的完整路径。该链路算法最差的复杂度为O（m^2）。

LS可能出现的问题。下图展示了一个简单的网络拓扑，图中的链路开销等于链路上承载的负载，且链路开销是非对称的，仅当在链路（u，v）两个方向所承载的负载相同是c(u,v)与c(v,u)才相等。

![LS](https://s2.ax1x.com/2020/01/18/1pZSFf.png)

该例中，节点z产生发往w的一个单元的流量，节点x也产生发往w的一个单元的流量，且节点y也产生发往w的一个数量为e的流量。上图展示了路由选择变化。

上述展示了路由选择的震荡。解决这一问题的方式一种是强制链路开销不依赖于所承载的流量，但该方案不可接收，路由就是避免高度拥塞的链路。另一种解决方案是确保并非所有路由器同时运行LS算法。

### 距离向量路由选路算法

距离向量（Distance-Vector，DV）算法是一种迭代的、异步的和分布式的算法。说其是分布式的，因为每个节点都要从一个都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居。说其是迭代的，因为此过程一直要持续到邻居之间无更多信息要交换为止。说是异步的，因为不要求所有节点相互之间步伐一致地操作。

令$ d_x(y)$是从节点x到节点y的最低开销路径的开销。则该最低开销与著名的Bellman-Ford方程相关，即：
$$
d_x(y) = min_v \vert c(x,v)+d_v(y) \vert
$$
方程中的$min_v$是对于x的所有邻居的。

DV算法基本思想为：每个节点x以$D_x(y)$开始，对N中所有节点y，估计从x到y的最低开销路径。令$D_x = [D_x(y):y\in N]$是节点x的距离向量，该向量是从x到在N中所有其他节点y的开销估计向量。使用DV算法，每个节点x维护下列路由选择信息：

1. 对于每个邻居v，从x到到直接相连邻居v的开销为c(x,v)。
2. 节点x的距离向量，即$D_x = [D_x(y):y\in N]$。包含了x到N中所有目的地y的开销估计值。
3. 它的每个邻居的距离向量，即对x的每个邻居v，有$D_v= [D_v(y):y\in N]$。

在该分布式、异步算法中，每个节点不时地向它的每个邻居发送它的距离向量副本。当节点x从它的任何一个邻居v接收到一个新距离向量时，它保存v的距离向量，然后使用Bellman-Ford方程更新它自己的距离向量：

$$
D_x(y) = min_v \vert c(x,v)+D_v(y)\vert 
$$
对N中每个节点

如果节点x的距离向量因这个更新步骤而改变，节点x接下来向它的每个邻居发送其更新后的距离向量，这继而让所有邻居更新它们自己的距离向量。该算法不断更新会使得$D_x(y)$收敛到$d_x(y)$。

距离向量（DV）算法：

在每个节点x：

```
Initialization:
	for all destination y in N
		D_x(y) = c(x,y) /*if y is not a neighbor then c(x,y) = 无穷*/
	for each neighbor w
		D_w(y) = ? for all destination y in N
	for each neighbor w
		send distiance vector D_x = [D_x(y):y in N] to w

loop
	wait (until I see a link cost change to some neighbor w or until I receive a distance vector from some neighbor w)
	for each y in N:
		D_x(y) = min_v{c(x,v)+D_v(y)}
if D_x(y) change for any destination y
	send disance vector D_x = [D_x(y) : y in N] to all neighbors
forever
```

![DV](https://s2.ax1x.com/2020/01/18/19CpdS.png)

上图展示了DV算法的运行（图上有个错误，x到y费用为2）。

#### 距离向量算法：链路开销改变与链路故障

当一个运行DV算法的节点检测到从自己到邻居的链路开销发送变化时，就更新其距离向量，如果最低开销路径的开销发生变化，向邻居通知其新的距离向量。对于开销降低的来说，不存在太多问题。算法很快就会恢复稳定，但是对于开销升高的来说，有可能出现路由选择环路（routing loop）。该情况如下图：

![routing loop](https://s2.ax1x.com/2020/01/19/19cl4A.png)

当x到y开销从4变道60时。算法运行：

1. 变换之前，$D_y(x) = 4$，$D_y(z) =1$，$D_z(y) = 1$，$D_z(x) = 5$。t0时刻y检测到链路开销变化。y计算到x的节点开销为：
   $$
   D_y(x) = min\{c(y,x)+D_x(x),c(y,z)+D_z(x)\}
   $$
   由于原来的$D_z(x)$就要经过链路变化的路径，而该链路不是第一个检测到变化的，因此，其费用$D_z(x)$此时是有问题的，但是算法无法检测到错误，而是依旧使用该费用。

2. 因为节点y算出到x的新的最低开销，在t1时刻将该新距离向量通知z。

3. z收到y的新距离向量，它指示了y到x最低开销是6。z知道其能够以1到达y，因此计算出到x的最低开销为$D_z(x) = min\{50+0,1+6\} =7$。由于z到x的最低开销已经增加了，于是在t2时刻通知y其新开销。

4. 以类似方式，在收到z的新距离向量后，y算出$D_y(x) = 8$并向z发送其距离向量。接下来z确定$D_z(x) = 9$并向y发送其距离向量，等等。

该过程知道z最终确定它经过有y的路径开销大于50为止。该问题有时被称为无穷计数问题。

#### 距离向量算法：增加毒性逆转

上述路由选择环路问题可以通过毒性逆转的技术加以避免。其思想为：如果z通过y路由选择到目的地x，则z将通告y，它到x的距离是无穷大。

毒性逆转并未解决一般的无穷计数问题，涉及三个或更多节点的环路将无法用毒性逆转计数检测到。

#### LS与DV路由选择算法比较

1. 报文复杂性：LS算法要求每个节点都知道网络中每条链路的开销，要求发送O（NE）个报文。DV算法要求在每次迭代时，在两个直接相连邻居之间交换报文。
2. 收敛速度：LS算法实现是一个要求O（NE）个报文的O（N^2）算法。DV算法收敛较慢。且在收敛时会遇到路由选择环路。DV算法还会遇到无穷计数问题。
3. 健壮性：在LS算法下，路由计算在某种程度上是分离的，提供了一定程度的健壮性。DV算法中一个不正确的节点计算值会扩散到整个网络。

## 因特网中自治系统内部的路由选择：OSPF

在实践中，路由选择需要考虑两点：

1. 规模：随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高的不可实现。
2. 管理自治：因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按照自己的意愿运行路由器，或对外部隐藏网络的内部组织面貌。理想情况下，一个组织应该能够按自己愿望运行和管理其网络，还要能将其网络与其它外部网络连接起来。

这两个问题都能够通过将网络组织进自治系统（Autonomous System，AS）来解决，其中每个AS由一组通常处在相同管理控制下的路由器组成。通常一个ISP中的路由器以及互联他们的链路构成了一个庞大的AS。某些ISP将他们的网络划分为多个AS。某些一级ISP在整个网络中使用一个庞大的AS，而其他ISP则将它们的ISP拆分为数十个互联的AS。一个自治系统由其全局唯一的AS号所标识。就像IP地址那样，AS号由ICANN区域注册机构所分配。

### 开放最短路优先（OSPF）

OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。使用OSPF，一台路由器构成了一副关于整个自治系统的完整拓扑图每台路由器在本地运行Dijkstra的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。

使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路状态发生变化时，路由器就会被广播链路状态信息。即使链路状态未发生变化，也要周期性地广播链路状态。OSPF通告包含在OSPF报文中，该OSPF报文直接由IP承载，对OSPF其上层协议的值为89。因此OSPF协议必须自己实现诸如可靠报文传输、链路状态广播等功能。OSPF协议还要检查链路正在运行，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库。

OSPF的优点包括下列方面：

1. 安全：能够鉴别OSPF路由器之间的交换。使用鉴别，仅有受信任的路由器参与一个AS内部的OSPF协议。
2. 多条相同开销的路径：当到达某目的地的多条路径具有相同开销时，OSPF允许使用多条路径。
3. 对单播与多播路由选择的综合支持：多播OSPF（MOSPF）提供对OSPF的简单扩展，以便提供多播路由选择。
4. 支持在单个AS中的层次结构：一个OSPF自治系统能够层次化地配置多个区域。每个区域都运行自己的OSPF链路状态路由选择算法，区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。

## ISP之间路由选择：BGP

自治系统间路由选择协议，使得所有AS运行相同的AS间路由选择协议，称为边界网关协议（Broder Gateway Protocol，BGP）。

### BGP的作用

对于位于相同AS中的目的地而言，路由转发表项由AS内部选路协议决定，对于位于该AS外部的目的地而言情况是BGP来处理。

在BGP中，分组并不是路由到一个特定的目的地址，相反是路由到CIDR化的前缀，其中每个前缀表示一个子网或一个子网的集合。BGP中，一个目的地可以采用138.16.68/22的形式。因此，一台路由器的转发表将具有形式为(x,I)的表项，其中x是一个前缀，I是该路由器接口之一的接口号。

BGP为每台路由器提供了一种完成以下任务的手段：

1. 从邻居AS获得前缀的可达性信息：BGP允许每个子网向因特网的其余部分通告它的存在，同时BGP确保在因特网中的所有AS知道该子网。
2. 确定到该前缀的“最好的”路由。一台路由器可能知道两条或更多到特定前缀的不同路由。为了确定最好的路由，该路由器将本地运行一个BGP路由选择过程。

### 通告BGP路由信息

![ASnet](https://s2.ax1x.com/2020/01/24/1Zi6u8.png)

上图展示了三个自治系统，其中AS3包含一个具有前缀x的子网。对于每个AS，每台路由器要么是一台网关路由器，要么是一台内部路由器。网关路由器是一台位于AS边缘的路由器，它直接连接到其他AS中的一台或多台路由器。内部路由器仅连接它自己AS中的主机和路由器。

在BGP中，每台路由器通过使用179端口的半永久TCP连接交换路由选择信息。每台直接连接以及所有通过该连接发送的BGP报文，称为BGP连接（BGP connection）。跨域两个AS的BGP会话称为外部BGP（eBGP）连接，而在相同AS中的两台路由器之间的BGP会话称为内部BGP（iBGP）连接。如下图：

![AS](https://s2.ax1x.com/2020/01/24/1Zisjf.png)

为了传播可达性信息，使用了iBGP和eBGP会话。考虑向AS1和AS2中的所有路由器通告前缀x的可达性信息。该过程，网关路由器3a先向网关路由器2c发送一个eBGP报文“AS3 x”。网关路由器2c然后向AS2中的所有其他路由器发送iBGP报文“AS3 x”。网关路由器2a接下来向网关路由器1c发送eBGP报文“AS2 AS3 x”。最后，网关路由器1c使用iBGP向AS1中的所有路由器发送报文“AS2 AS3 x”。这个过程完成后，在AS1和AS2中的所有路由器知道了x的存在并且也知道了通往x的AS路径。

### 确定最好的路由

因特网中的路由器常常接到很多不同的可能路径的可达性信息。这里讨论如何选择不同的路径。当路由器通过BGP连接通告前缀时，它在前缀中包括一些BGP属性（BGP attribute）。BGP术语来说，前缀及其属性称为路由（route）。两个较为重要的属性是AS-PATH和NEXT-HOP。AS-PATH属性通告已经通过的AS的列表，如前面看到的那样，为了生成AS-PATH的值，当一个前缀通过某AS时，该AS将其ASN加入AS-PATH中现有的列表。如下图：

![AS](https://s2.ax1x.com/2020/01/24/1ZirgP.png)

AS1到子网x有两条路径：其中一条使用AS-PATH “AS2 AS3”；另一条使用AS-PATH “AS3”。BGP路由器使用AS-PATH属性来检测和防止通告环路：特别的，如果一台路由器在路径列表中包含自己的AS，它将拒绝该通告。

在AS间和AS内部路由选择协议之间提供关键链路方面，NEXT-PATH属性具有敏感而重要的作用。NEXT-HOP是AS-PATH起始路由器接口的IP地址。参考上图，对于从AS1通过AS2到x的路由“AS2 AS3 x”，其属性NEXT-HOP是路由器2a左边接口的IP地址。对于从AS1绕过AS2到x的路由器“AS3 x“，其NEXT-HOP属性是路由器3d最左边接口的IP地址。该例中，AS1中每台路由器都知道了前缀x的两台BGP路由：

```
路由器2a的最左侧接口的IP地址：AS2 AS3；x
路由器3d的最左侧接口的IP地址：AS3；x
```

这里，每个BGP路由包含3个组件：NEXT-HOP；AS-PATH；目的前缀。

#### 热土豆路由选择

使用热土豆路由选择，选择的路由到开始该路由的NEXT-HOP路由器具有最小开销。考虑上图中1b路由器，这台路由器将选择到达前缀x的两条两条BGP路由。1b将首先查阅AS内部路由信息，以找到通往NEXT-HOP路由器2a的最低开销AS内部路径已经通往NEXT-HOP路由器3d的最低开销AS间路径，进而选择这些开销中最低开销的那条。例如，定义开销为穿越的链路数量。则从1b到2a的开销为2,1b到3d的开销为3。因此路由器将选择2a。路由器1b查阅转发表（AS内部算法所配置），找到通往路由器2a的位于最低开销路径上的接口I。1b把（x，I）放到其转发表中。

下图展示了一台路由器转发表中对于热土豆路由选择增加AS向外前缀的步骤。当在转发表中增加AS向外前缀时，AS间路由选择协议（BGP）和AS内部路由选择协议（如OSPF）都会用到：

![hot potato](https://s2.ax1x.com/2020/01/28/1KaIud.png)

热土豆路由选择依据的思想是：对于路由器1b，尽可能块地将分组送出其AS，而不担心其AS外部到目的地的余下部分开销。热土豆路由选择算法是自私的算法，即其试图减小在它自己AS中的开销，而忽略在其AS之外的端到端开销的其他部分。

#### 路由器选择算法

实践中，BGP使用了一种比热土豆路由选择更为复杂但却结合了其特定的算法。对于任何给定的目的地前缀，进入BGP的路由选择算法的输入是到该前缀的所有路由的集合，该前缀是已被路由器学习和接受的。如果只有一条，则直接选该条即可，如果存在多条，则按下面顺序筛选，直至只有一条为止：

1. 路由被指派一个本地偏好值作为其属性之一（除AS-PATH和NEXT-HOP）。一条路由的本地偏好值可能由该路由器设置或可能由在相同AS中的另一台路由器中学到。具有最高本地偏好值的路由器被选择。
2. 从被选择的路由中（具有相同最高本地偏好值），将选取具有最短AS-PATH的路由。如果该规则是路由选择的唯一规则，则BGP将使用距离向量算法决定路径，其中距离测量使用AS跳数而不是路由器跳数。
3. 从余下的路由中（具有相同本地偏好值和相同的AS-PATH长度），使用热土豆路由选择，选择具有最靠近NEXT-HOP路由器的路由。
4. 如果任留下多条路由，该路由器使用BGP标识符来选择路由。

### IP任播

除了作为因特网AS间路由选择协议外，BGP还常被用来实现IP任播（anycast）服务，该服务常用于DNS中。为了说明IP任播动机，考虑下列应用场景：1）在许多分散的不同地理位置，替换不同服务器上的相同内容；2）让每个用户从最靠近的服务器访问内容，如CDN。

这里讨论CDN可能使用IP任播的方式。如下图，在IP任播配置阶段，CDN公司为它的多台服务器指派相同的IP地址，并且使用标准的BGP从这些服务器的每台来通告该IP地址。

![5-12](https://s2.ax1x.com/2020/01/28/1KLFne.png)

当某台BGP路由器接收到对于该IP地址的多个路由通告时，它将这些通告处理为对相同的位置提供不同的路径（实际是这些通告对不同地址位置是有不同的路径）。当配置其路由选择表时，每台路由器讲本地化地使用BGP路由选择算法来挑选到该IP地址的最好的路由。在这个初始BGP地址通告阶段后，CDN能够进行其分发内容的主要任务。当某客户请求内容时，CDN向该客户返回由地理位置上分散的服务器所使用的共同IP地址，而无论该客户位于何处，当该客户想要向那个IP地址发送一个请求时，因特网路由器则向那个“最近的”服务器转发该请求。

实践中CDN通常选择不使用IP任播，因为BGP路由选择变化能够导致相同的TCP连接的不同分组到达Web服务器的不同实例（IP任播一般不应该用于TCP连接）。IP任播被DNS系统广泛用于将DNS请求指向最近的根DNS服务器（DNS基于UDP，不用建立连接）。

### 路由选择策略

![5-13](https://s2.ax1x.com/2020/01/29/1M5Zwt.png)

上图展示了一个简单例子，其中包含6个互联的自治系统（是AS不是路由器）。其中W、X和Y是接入ISP，而A、B和C是主干提供网络。假设A、B和C直接向彼此发送流量，并向它们的客户网络提供全部的BGP信息。所有进入一个接入ISP网络的流量必定是以该网络为目的地，所有离开一个接入ISP网络的流量必定源于该网络。W和Y显然是接入ISP。X是一个多宿接入ISP，因为它是经由两个不同的提供商连到网络的其余部分。然而，如W和Y一样，X自身必定是进入/离开X的所有流量的源/目的地。X防止转发B与C之间的流量，通过控制BGP路由的通告方式，即X（向其邻居B和C）通告它没有通向任何其他目的地的路径，那么它将起到一个接入ISP的作用。

## SDN控制平面

SDN结构具有4个关键特性：

1. 基于流的转发：SDN控制的交换机的分组转发工作，能够基于运输层、网络层或链路层首部中任意数量的首部字段值进行。传统方法中的IP数据报的转发仅依据数据报的目的IP地址进行。

2. 数据平面与控制平面分离：如下图

   ![5-14](https://s2.ax1x.com/2020/01/29/1MoaM4.png)数据平面由网络交换机组成，交换机是相对简单的设备，该设备在他们的流表中执行“匹配加动作”的规则。控制平面由服务器以及决定和管理交换机流表的软件组成。

3. 网络控制功能：位于数据平面交换机外部。SDN中的S表示软件，即SDN控制平面由软件实现。软件在服务器上执行，该服务器与网络交换机分离。如上图，控制平面由两个组件组成：一个SDN控制器（网络操作系统），以及若干网络控制应用程序。控制器维护准确的网络状态信息（如远程链路、交换机和主机的状态）；为运行在控制平面中的网络控制应用程序提供这些信息；提供方法，这些应用程序通过这些方法能够监视、编程和控制下面的网络设备。

4. 可编程的网络：通过运行在控制平面中的网络控制应用程序，该网络是可编程的。

SDN表示了一种意义重大的网络功能的分类，即数据平面交换机、SDN控制器和网络控制应用程序是分离的实体，该实体可以由不同的厂商和组织机构所提供。

### SDN控制平面：SDN控制器和SDN网络控制应用程序

![5-15](https://s2.ax1x.com/2020/01/29/1MH3dA.png)

上图展示了一个通用SDN控制器详尽的视图。控制器的功能可大体组织为3个层次。以非典型的自底向上方式考虑这些层次：

1. 通信层：SDN控制器和受控网络设备之间的通信。SDN控制器要控制远程SDN使能的交换机、主机或其他设备的运行，需要一个协议来传送控制器与这些设备之间的信息。此外，设备必须能够向控制器传递本地观察到的事件（如，一个报文指示一条附属链路已经激活或停止，一个设备刚刚加入了网络，或一个心跳指示某设备已经启动和运行）。这些事件向SDN控制器通过该网络状态的最新视图。该协议构成了控制器体系结构最底层。控制器与受控设备之间的通信跨越了一个接口，被称为控制器的“南向”接口。OpenFlow是一种提供这种通信功能的特定协议。
2. 网络范围状态管理层：由SDN控制平面所做出的最终控制决定（例如配置所有交换机流表以取得所希望的端到端转发，实现负载均衡，或实现一种特定的防火墙功能），将要求控制器具有有关网络的主机、链路、交换机和其他SDN控制设备的最新状态信息。
3. 对于网络控制应用程序的接口：控制器通过它的“北向”接口与网络控制应用程序交互。该API允许网络控制应用程序在状态管理层之间读/写网络状态和流表。当状态改变事件出现时，应用程序能够注册进行通告。

SDN控制器被认为是“逻辑上集中”的，即该控制器可以被外部视为一个单一、整体的服务。但处于故障容忍、高可用性或性能等方面的考虑，实践中这些服务和用于保持状态信息的数据库一般通过分布式服务器实现。在服务器集合实现控制器功能时，必须考虑控制器的内部操作（如维护事件的逻辑时间顺序、一致性、意见一致等）的语义。

### OpenFlow协议

OpenFlow协议运行在SDN控制器和SDN控制的交换机或其他实现OpenFlow API的设备之间。OpenFlow协议运行在TCP之上，使用6653默认端口。从控制器到受控交换机流动的重要报文有下列这些：

1. 配置：该报文允许控制器查询并设置交换机的配置参数。
2. 修改状态：该报文由控制器所使用，以增加/删除或修改交换机流表中的表项，并且设置交换机端口特征。
3. 读状态：该报文被控制器用于从交换机的流表和端口收集统计数据和计数器值。
4. 发送分组：该报文被控制器用于在受控交换机从特定的端口发送一个特定的报文。

从受控交换机到控制器流动的重要报文有下列这些：

1. 流删除：该报文通知控制器已删除一个流表项，如由于超时，或作为收到“修改状态”报文的结果。
2. 端口状态：交换机用该报文向控制器通知端口状态的改变。
3. 分组入：一个分组到达交换机端口，并且不能与任何流表项匹配，那么这个分组将被发送给控制器进行额外处理。匹配的分组也被发送给控制器，作为匹配时所采取的一个动作。该报文被用来将分组发送给控制器。

### 数据平面与控制平面交互的例子

![5-16](https://s2.ax1x.com/2020/01/30/1l1ws1.png)

考虑上图例子，其中使用了Dijkstra算法来决定最短路径路由。上图中SDN与传统每路由器控制场景有两个重要差异，Dijkstra算法是实现在每台路由器中并且在所有网络路由器中洪泛链路状态更新：

1. Dijkstra算法作为一个单独的程序来执行，位于分组交换机的外部。
2. 分组交换机向SDN控制器发送链路更新并且不互相发送。

该例中，我们假设交换机s1和s2之间链路断开；实现了最短路径路由选择，因此，除了s2操作未改变外，s1，s3，s4的入和出流转发规则都收到影响。同时假定OpenFlow被用作通信层协议，控制平面只执行链路状态路由选择而不执行其他功能。

1. 交换机s1经历了自己与s2之间的链路故障，使用OpenFlow“端口状态”报文向SDN控制器通报该链路状态更新。
2. SDN控制器接收指示链路状态更新的OpenFlow报文，并且通告链路状态管理器，由管理器更新链路状态库。
3. 实现Dijkstra链路状态路由选择的网络控制应用程序先进行了注册，当链路状态更新时将得到通告。应用程序接收该链路更新的通告。
4. 链路状态路由选择应用程序与链路状态管理器相互作用，以得到更新的链路状态；它也会参考状态管理层中的其他组件。然后它计算新的最低开销路径。
5. 链路状态路由选择应用程序与流表管理器交互，流表管理器决定更新的流表。
6. 流表管理器使用OpenFlow协议更新位于受影响的交换机s1、s2和s4的流表项。

### SDN的过去与未来

SDN革命正颠覆性地替代专用的整体交换机和路由器。网络功能虚拟化（NFV）的通用SDN的目标是用简单的商用服务器、交换机和存储器来颠覆性地替代复杂的中间盒。第二个重要研究领域是寻求将SDN概念从AS内部扩展到AS之间设置。

## ICMP：因特网控制报文协议

因特网控制报文协议（ICMP）被主机和路由器之间来彼此沟通网络层的信息。ICMP最典型的用途是差错报告。

ICMP通常被认为是IP的一部分，但从体系结构上来讲它位于IP之上，因为ICMP是承载在IP分组中。即ICMP报文是作为IP有效载荷的，就像TCP与UDP报文段作为IP有效载荷那样。当一台主机收到一个指明上层协议为ICMP的IP数据报时（上层协议编码为1），它分解出该数据报的内容给ICMP。

ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节（以便发送方确定引发该差错的数据报）。下表展示了ICMP报文类型：

| ICMP类型 | 编码 | 描述                     |
| -------- | ---- | ------------------------ |
| 0        | 0    | 回显回答（对ping的回答） |
| 3        | 0    | 目的网络不可达           |
| 3        | 1    | 目的主机不可达           |
| 3        | 2    | 目的协议不可达           |
| 3        | 3    | 目的端口不可达           |
| 3        | 6    | 目的网络未知             |
| 3        | 7    | 目的主机未知             |
| 4        | 0    | 源抑制（拥塞控制）       |
| 8        | 0    | 回显请求                 |
| 9        | 0    | 路由器通告               |
| 10       | 0    | 路由器发现               |
| 11       | 0    | TTL过期                  |
| 12       | 0    | IP首部损坏               |

ping程序发送一个ICMP类型8编码0的报文到指定主机。看到回显（echo）请求，目的主机发送一个类型0编码0的ICMP回显回答。大多数TCP/IP实现直接在操作系统中支持ping服务器，该服务器不是一个进程。

Traceroute是用ICMP报文实现的。为了判断源和目的地之间所有路由器的名字和地址，源主机中的Traceroute向目的地主机发送一系列普通的IP数据报。这些数据报的每个携带一个具有不可达UDP端口号的UDP报文段。第一个数据报的TTL是1，第二个TTL是2，第三个TTL是3，以此类推。该源主机也为每个数据报启动定时器。当第n个数据报到达第n台路由器时，刚好过期，路由器丢弃该分组并发送一个ICMP告警报文。

Traceroute源主机停止发送报文发送为：数据报包含了一个具有不可达端口号的UDP报文段，当达到目的主机时，该主机将向源发送一个不可达的ICMP报文。当源主机收到这个特别的ICMP报文时，就知道不需要再发送探测分组了。

## 网络管理和SNMP

网络管理包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价和控制网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求。

### 网络管理框架

![5-20](https://s2.ax1x.com/2020/01/30/1lcm7T.png)

上图展示了网络关联的关键组件。主要包括：

1. 管理服务器：一个应用程序，通常有人的参与，并运行在网络运营中心（NOC）的集中式网络管理工作站上。管理服务器是执行网络管理活动的地方，它控制网络管理信息的收集、处理、分析和/或显示。在这里，发起控制网络行为的动作，人类网络管理员与网络设备进行交互。
2. 被管理设备：是网络设备的一部分（包括其软件），位于被管理的网络中。被管理设备可以是主机、路由器、交换机、中间盒、调制解调器或其他联网设备。这些被管对象是被管设备中硬件的实现部分和用于这些硬件及软件组件的配置参数。
3. 一个被管设备中的每个被管对象的关联信息收集在管理信息库（Management Information Base，MIB）中，这些信息的值可供管理服务器所用（在许多场合下能被设置）。一个MIB对象可以是：一个计数器，如用于IP数据报首部差错而由路由器丢弃的IP数据报数量，或一台主机接收到的UDP报文段的数量；运行在一台DNS服务器上的软件版本的描述性信息；一个特定设备功能是否正确的状态信息；一个目的地路由选择的特定协议的信息。MIB对象由称为SMI（Structure of Management Information）的数据描述语言所定义。使用形式化定义语言可以确保网络管理数据的语法和语义是定义良好的无二义性的。、
4. 在每个被管理设备中还驻留有网络管理代理（network management agent）。它是运行在被管理设备中的一个进程，该进程与管理服务器通信，在管理服务器的命令和控制下在被管理设备中采取本地动作。
5. 网络管理框架最后组件是网络管理协议（network management Protocol）。该协议运行在管理服务器和被管设备之间，运行管理服务器查询被管理设备的状态，并经过其代理间接地在这些设备上采取行动。代理能够使用网络管理协议向管理服务器通知异常事件（如组件故障或超过了性能阈值）。网络管理协议自己不能管理网络，它为管理员提供了一种能力，使得他们能够管理（监视、测试、轮询、配置、分析、评价和控制）网络。

### 简单网络管理协议

简单网络管理协议（Simple Network Management Protocol）版本2（SNMPv2）是一个应用层协议，用于在管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文。SNMP最常用的是请求响应模式，其中SNMP管理服务器向SNMP代理发送一个请求。代理接收到该请求后，执行某些动作，然后对该请求发送一个回答。请求通常用于查询（检索）或修改（设置）与某管理设备管理的MIB对象值。SNMP第二个常被使用的是代理向管理服务器发送一个非请求报文，该报文称为陷阱报文（trap message）。陷阱报文用于通知管理服务器，一个异常情况（如一个链路接口启动或关闭）已导致了MIB对象值的改变。

下表列出了SNMPv2定义的7种类型的报文，这些报文一般称为协议数据单元（PDU）。

| SNMPv2 PDU类型 | 发送方-接收方              | 描述                                 |
| -------------- | -------------------------- | ------------------------------------ |
| GetRequest     | 管理者到代理               | 取得一个或多个MIB对象实例            |
| GetNextRequest | 管理者到代理               | 取得列表或表格中下一个MIB对象实例值  |
| GetBulkRequest | 管理者到代理               | 以大数据块方式取得值，例如大表中的值 |
| InformRequest  | 管理者到管理者             | 向不能访问的远程管理实体通知MIB值    |
| SetRequest     | 管理者到代理               | 设置一个或多个MIB对象实例的值        |
| Response       | 代理到管理者或管理者到代理 | 对上述5个PDU产生的响应               |
| SNMPv2-Trap    | 代理到管理者               | 向管理者通知一个异常事件             |

![5-21](https://s2.ax1x.com/2020/01/31/11y5h4.png)

1. GetRequest、GetNextRequest和GetBulkRequest PDU都是管理服务器向代理发送的，以请求位于该代理所在的被管理设备中一个或多个MIB对象值。其值被请求的MIB对象的对象标识符定义在该PDU的变量绑定部分。三者差异体现在请求粒度。GetRequest请求MIB值的任意集合；多个GetNextRequest能够用于属性地读取MIB对象的列表或表格；GetBulkRequest允许读取大块数据，能够避免因发送多个GetRequest或GetNextRequest报文可能导致的额外开销。三个情况下，代理服务器使用包括该对象标识符和它们相关值的Response PDU进行响应。
2. 管理服务器使用SetRequest PDU来设置位于被管理设备中一个或多个MIB对象值。代理用带有“noError”差错状态的Response PDU进行应答，以证实该值的确已被设置。
3. 管理服务器使用InformResponse PDU来通知另一个MIB信息管理服务器，后者对于接收服务器是远程的。
4. Response PDU通常从被管理设备发送给管理服务器，以响应来自该服务器的请求报文，返回所请求的信息。
5. SNMPv2 PDU的最后一种类型是陷阱报文。陷阱报文是异步产生的，即它们不是为了响应接收到的请求而产生的，而是为了响应管理器要求通知的事件而产生的。

SNMP PDU通常使用UDP作为运输协议。

# 第六章 链路层和局域网

## 链路层概述

运行链路层协议的任何设备均被称为节点。节点包括主机、交换机和WiFi接入的。我们把沿着通信路径连接相邻节点的通信信道称为链路。网络层否则信息从一个主机到另一个主机的传输，链路层负责从一个节点到另一个节点的传输。

### 链路层提供的服务

链路层可能提供的服务包括：

1. 成帧：网络层数据报经链路传输之前，几乎所有链路层协议都要将链路层帧封装起来。一个帧由一个数据字段和若干首部字段组成，其中网络层数据报就插在数据字段。
2. 链路输入：媒体访问控制（Medium Access Control,MAC）协议规定了帧在链路上传输的规则。MAC协议用于协调多个节点的帧传输。
3. 可靠交付：但链路层协议提供可靠交付访问时，它保证无差错地经链路层移动每个网络层数据报。
4. 差错检验和纠正：比特差错是由信号衰减和电磁噪声导致的。链路层协议提供一种机制来检测这样的比特差错。

### 链路层在何处实现

下图显示了典型的主机体系结构：

![6-2](https://s2.ax1x.com/2020/02/03/1UPyFg.png)

链路层的主体部分是在网络适配器（network adapter）中实现，网络适配器有时也称为网络接口卡（Network Interface Card，NIC）。控制器通常是一个实现许多链路层服务等待专用芯片。因此链路层控制器很多功能是用硬件实现的。上图展示出，尽管大部分链路层是在硬件中实现，但部分链路层是在运行于主机CPU上的软件实现的。链路层的软件组件实现了高层链路功能，如组装链路层寻址信息和激活控制器硬件。在接收端，链路层软件响应控制器中断，处理差错检验和将网络向上传递给网络层。因此，链路层是硬件和软件的结合体，即此处是协议栈中软件与硬件交接的地方。

## 差错检测和纠正技术

![6-3](https://s2.ax1x.com/2020/02/03/1UFSuq.png)

上图说明了研究环境，为了保护比特免受差错，使用检测和纠正比特（Error-Detection and Correction，EDC）来增强数据D。链路级帧中的D和EDC都被发送到接收节点。在接收节点，接收比特序列D‘和EDC’。D‘与EDC’可能与初始的D和EDC不同。

接收方的挑战是在它只收到D‘和EDC’的情况下，确定D‘是否和初始的D相同。

### 奇偶校验

奇偶校验（parity bit）中，假设要发送信息D有d比特，只需要包含一个附加比特，选择它的值，使得这d+1比特中1的总数是偶数。如下图：

![6-4](https://s2.ax1x.com/2020/02/03/1UAvgH.png)

下图展示了单比特奇偶校验方案的二维一般化方案。D中的d个比特被划分为i行j列，对每行和每列计算奇偶值：

![6-5](https://s2.ax1x.com/2020/02/03/1UENrR.png)

使用二维奇偶校验方案，接收方不仅可以检测出现单个比特错误，而且可以利用行列索引来纠正它。

接收方检测和纠正差错的能力被称为前向纠错（Forward Error Correction，FEC）。

### 校验和方法

校验和方法与TCP和UDP使用的类似，d比特数据被看做一个k比特整数的序列处理。简单的方式是将这k比特整数加起来，并且用得到的和作为差错检验比特。

### 循环冗余检测

循环冗余检测（Cycle Redundancy Check，CRC）编码也称为多项式编码，因为该编码能够将要发送的比特串看作为系数是0和1的一个多项式，对比特串的操作被解释为多项式算术。

CRC编码操作如下。考虑d比特的数据D，发送节点要将它发送给接收节点。发送方和接收方首先必须协商一个r+1比特，模式，称为生成多项式，我们将其表示为G。要求G的最高有效位是1.CRC编码思想如下图：

![6-6](https://s2.ax1x.com/2020/02/03/1UQ8Gq.png)

对于一个给定的数据D，发送方要选择r个附加比特R，并将它们附加到D上，使得得到的d+r比特模式用模2算术恰好能够被G整除。用CRC进行差错检测过程因此十分简单：接收方用G去除接收到的d+r比特。如果余数非0，接收方知道出现了差错。

所有CRC计算采用模2算术来做，在加法中不进位，在减法中不借位。即加分和减法是相同的，而且均等同于按位异或（XOR）。除了加减法操作没有进位和借位外，乘法和除法与二进制算术中是相同的。这样给定D和R，D*2^r XOR R产生上图的d+r比特模式。

现在我们考虑如何计算R这个问题。前面讲过，我们要求出R使得对n有：
$$
D * 2^r XOR R = nG
$$
即我们要选择R使得G能够除以$D*2^r XOR R$而没有余数。对上述等式两边都用R异或，得到：
$$
D*2^r = nG XOR R
$$
该等式说明，用G来除$D*2^r$,余数刚好是R，即：
$$
R=remainder \frac{D*2^r}{G}
$$
CRC-32 32比特的标准被多种链路级IEEE协议采用。每个CRC标准都能够检测小于r+1比特的突发差错，长度大于r+1比特的突发差错以概率1-0.5^r被检查到。

## 多路访问链路和协议

广播链路（broadcast link）能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。如何协调多个发送和接收节点对一个共享广播信道的访问，即为多路访问问题（myltiple access problem）。广播信道通常用于局域网中，局域网是一个地理上集中在一座建筑物中的网络。

多路访问问题通过使用多路访问协议（multiple access protocol）来解决。即节点通过这些协议来规范它们在共享的广播信道上的传输行为。

所有节点都能够传输帧，所以多个节点可能会同时传输帧。这时，所有节点同时接到多个帧：即传输的帧在所有的接收方处碰撞。当发生碰撞时，没有一个接收节点能够有效地获得任何传输的帧：碰撞的帧的信号纠缠在一起。涉及此处传输的所有帧都丢失了，在碰撞时间间隔的广播信道被浪费了。

对于速率为Rbps的广播信道，多路访问协议一个具有下列锁希望的特性：

1. 当仅有一个节点发送数据时，该节点具有Rbps的吞吐量。
2. 当有M个节点发送数据时，每个节点吞吐量为R/Mbps（平均）。
3. 协议是分散的：就是说不会因为某主节点故障而使得整个系统崩溃。
4. 协议简单的，使实现不昂贵。

### 信道划分协议

时分多路复用（TDM）和频分多路复用（FDM）是两种能够用于所有共享信道节点之间划分广播信道带宽的技术。

TMD消除了碰撞，而且公平，但节点被限制于R/Nbps的平均速率，即使当它是唯一有分组要传输的节点，其次节点必须总是等待它在传输序列上的轮次。

FMD避免了碰撞，在N个节点之间公平的划分了带宽。然而它也限制了一个节点只能够使用R/N的带宽。

第三种信道划分是码分多址（Code Division Mulitiple Access，CDMA）。CMDA为每个节点分配一中不同的编码，然后每个节点使用其唯一的编码来对它发送的数据进行编码。精心选择这些编码，可以使得不同节点同时传输而且接收方能够正确接收。

### 随机接入协议

在随机接入协议中，一个传输节点总是以信道的全部速率进行发送。当有碰撞时，设计碰撞的每个节点反复地重发它的帧，到该帧无碰撞地通过为止。但当一个节点经历一次碰撞时，它不必立即重发该帧。相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个节点独立的随机选择随机时延。

#### 时隙ALOHA

我们假设：

1. 所有帧由L比特组成。
2. 时间被划分成为长度为L/R秒的时隙。
3. 节点只在时隙起点开始传输帧。
4. 节点是同步，每个节点都知道时隙何时开始。
5. 如果在一个时隙中有两个或者更多个帧碰撞，则所有节点在该时隙结束之前检测到该碰撞事件。

p为一个概率，每个节点中，时隙ALOHA的操作是简单的：

1. 当节点有一个新帧要发送时，它等到下一个时隙开始并且在该时隙传输整个帧。
2. 如果没有碰撞，该节点成功传输它的帧，从而不用考虑重传该帧。
3. 如果有碰撞，该节点在时隙结束之前检测到该碰撞。该节点以概率p在后续的每个时隙中重传该帧，直到该帧被无碰撞的传输出去。

ALOHA优点：当某节点是唯一传输的节点，允许该节点以全速R连续传输。时隙ALOHA是高端分散的，每个节点检测到碰撞并独立地决定什么时候重传。

刚好有一个节点传输的时隙称为一个成功时隙（successful slot）。时隙多路访问协议的效率定义为：当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的份额。

考虑时隙ALOHA最大效率的推倒过程：假设每个节点视图在每个时隙以概率p传输一帧。假设有N个节点。则一个给定时隙是成功时隙的概率为节点之一传输而余下的N-1个节点不传输的概率，因此一个节点成功传输的概率是$p(1-p)^{N-1}$，任意一个时隙成功传输的概率是$Np(1-p)^{N-1}$。

为获取最大效率，当N趋于无穷时，我们取$Np(1-p)^{N-1}$的极限，此时最大效率是1/e = 0.37，即当有大量节点要传输时，最多有37%的时隙做有用的工作。

#### ALOHA

时隙ALOHA协议要求所有节点同步它们的传输，以在每个时隙开始时开始传输。第一个ALOHA协议实际是一个非时隙的，完全分散的协议。当一个帧首次到达，节点立即将该帧完整地传输进广播信道。如果一个传输的帧与一个或多个传输经历了碰撞，这个节点将立即以概率p重传，否则，该节点等待一个帧传输时间，在等待之后，它以概率p传播该帧。

#### 载波监听多路访问（CSMA）

载波监听（carrier sensing）即一个节点在传输前先听信道，如果检测到来自另一个节点的帧正在向信道发送，节点则等待知道检测到一小段时间没有传输，然后开始传输。

碰撞检测（collision detection）即当一个传输节点在传输时一致在监听此信道。如果它检测到另一个节点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时传输”循环之前等待一段时间。

这两个规则包含在载波侦听多路访问（Carrier Sense Multiple Access，CSMA）和具有碰撞检测的CSMA协议族中。

下图左侧展示了CSMA协议工作方式。

![6-1213](https://s2.ax1x.com/2020/02/03/1dbXfx.png)

#### 具有碰撞检测的载波侦听多路访问（CSMA/CD)

上图左侧，节点没有进行碰撞检测，即使出现了碰撞，B和D都将完整的传输它们的帧。当节点执行碰撞检验时，一旦它检测到碰撞将立即停止传输。上图右侧展示了该协议工作方式。

从与广播信道相连的适配器的角度来总结其运行：

1. 适配器从网络层获取一条数据报，准备链路层帧，并将其放入帧适配器缓存中。
2. 如果适配器侦听到信道空闲（96比特检测），它开始传输帧，另一方面，如果帧适配器侦听到信道正忙，它就等待，知道侦听到没有信号能够时才开始传输帧。
3. 在传输过程中，适配器监视来自其他使用该广播信道的适配器信号能量的存在。
4. 如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。另一方面，如果适配器在传输时检测大奥来自其他适配器的信号能量，它就中止传输帧（以太网中不直接停止，而是传输一个48比特的阻塞信号）。
5. 中止传输后，适配器等待一个随机时间量，然后返回步骤2。

对于等待的一个随机时间，用以太网以及DOCSIS电缆网络多路访问协议中的二进制指数后退（binary exponential backoff）算法来进行选择。当传输一个给定帧时，在该帧经历了一连串n次碰撞后，节点随机地从[0,1,2.……，2^n - 1]中选择一个K值。碰撞越多，K选择的间隔越大。

#### CSMA/CD效率

CSMA/CD效率定义为：当有大量的活跃节点，且每个节点有大量的帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占份额。$d_{prop}$表示信号能量在任意两个适配器之间传输所需要的最大时间。$d_{trans}$表示传输一个最大长度的以太网帧的时间。其效率如下：
$$
效率=\frac{1}{1+5d_{prop}/d_{trans}}
$$

### 轮流协议

这里主要介绍两种轮流协议：轮询协议和令牌传递协议。

轮流协议要求这些节点之一要被指定为主节点，主节点以循环的方式轮询每个节点。主节点首先向节点1发送一个报文，告诉它能够传输的帧的最多数量。在节点传输了某些帧后，主节点告诉节点2它能够传输的帧的数量。其中主节点能够通过观察在信道上是否缺乏信号来决定一个节点何时完成了帧的发送。

轮询协议消除了随机接入协议的碰撞和空时隙，使得轮询取得更高的效率。缺点是引入轮询时延，即通知一个节点其可以传输的时间。第二个缺点是，如果主节点故障，整个信道会变得不可操作。

令牌传递协议中，没有主节点，一个称为令牌的小的特殊帧在节点之间以某种固定的次序进行交换。如1把令牌交给2,2把令牌交给3，节点N将令牌交给1。当一个节点收到令牌时，仅当它有一些帧要传输时，它才持有该令牌，否则立即向下一个节点转发该令牌。当一个节点收到令牌时，如果确实有帧要传输，它发送最大数目的帧数，然后把令牌转发给下一个节点。令牌传递协议效率高，缺点则是，一个节点的故障可能会使整个信道崩溃。如果一个节点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回循环中来。

DOCSIS：用于电缆因特网接入的链路层协议

一个电缆网头端将几千个住宅电缆调制解调器与一个电缆调制解调器端接系统（Cable Modem Termination System，CMTS）连接。数据经电缆访问接口（Data-Over-Cable Service Interface，CMTS）规范定义了电缆数据网络体系结构及其协议。DOCSIS使用FDM将下行（CMTS到调制解调器）和上行（调制解调器到CMTS）网络段划分为多个频率信道。CMTS在下行信道上传输的帧被所有在信道上做接收的电缆调制解调器接收到；然而因为仅有单一的CMTS在下行信道上传输，不存在多路访问问题。在上行方向多个电缆调制解调器共享到CMTS的相同上行信道，因此能够潜在地出现碰撞。

每条上行信道被划分为时间间隔（类似于TDM），每个时间间隔包含一个微时隙序列，电缆调制解调器可在该微时隙中向CMTS传输。CMTS显式地准许各个电缆调制解调器在特定的微时隙中进行传输。CMTS在下行信道上通过发送MAP报文的控制报文来指定哪个电缆调制解调器哪个在微时隙中传输由控制报文指定的时间间隔。微时隙明确分配给电缆调制解调器，故CMTS能够确保在微时隙中没有碰撞传输。

![6-14](https://s2.ax1x.com/2020/02/04/10LxwF.png)

CMTS一开始如何知道哪个电缆调制解调器有数据要发送？通过让电缆调职解调器在专用于此目的的一组特殊的微时隙间隔内向CMTS发送微时隙请求帧来完成该任务。如上图，这些微时隙请求帧以随机接入方式传输（可能发生碰撞）。电缆调制解调器不能侦听上行信道是否忙，也不能检测碰撞。其如果没有在下一个下行控制报文中收到对该请求分配的响应的话，就推断请求经历1了一次碰撞。当推断出碰撞，使用二进制指数回退将其为时隙请求帧延缓到以后的时隙重新发送。

## 交换局域网

### 链路层寻址和ARP

#### MAC地址

并不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址。具有多个网络接口的主机或路由器将具有与之相关联的多个链路层地址。<font color =red>链路层交换机并不具有与它们的接口相关联的链路层地址，因为链路层交换机的任务是在主机与路由器之间承载数据报，交换机透明地执行该项任务，即主机或路由器不必明确地将帧寻址到其间的交换机。</font>下图说明了这中情况：

![6-16](https://s2.ax1x.com/2020/02/04/1Baq9x.png)

链路层地址存在多种称呼：LAN地址（LAN address）、物理地址（physical address）或MAC地址（MCA address）。MAC地址长度为6字节，这些6个字节地址通常用十六进制表示法，地址每个字节被表示为一对十六进制数。没有两块适配器具有相同的MAC地址，这是因为IEEE负责分配MAC地址。分配方式是：固定一个MAC地址的前24比特，让公司自己为每个适配器生成后24比特的唯一组合。

适配器的MAC地址具有扁平的结构，而且不论适配器到哪里都不会改变。

当适配器要向某些目的地适配器发送一个帧时，发送适配器将目的地的适配器MAC地址插入到该帧中，并将该帧发送到局域网。当适配器接收到一个帧时，将检查该帧中的目的MAC地址是否与自己的MAC地址匹配。如果匹配，该适配器提取出封装的数据并沿协议栈向上传输。如果不匹配，适配器丢弃该帧。

有时发送适配器要让局域网上所以其他适配器来接收并处理发送的帧，此时，发送适配器在该帧的目的地字段中插入特殊的MAC广播地址（FF-FF-FF-FF-FF-FF）。

MAC存在的原因：

1. 局域网是为任意网络层协议而设计的，而不是只用于IP和因特网，不使用MAC地址，适配器不能够方便地支持其他网络层协议。
2. 如果适配器使用网络层地址而不是MAC地址，网络层地址需存储在适配器的RAM中，并且每次适配器移动（或加电）时要重新配置。
3. 如果不使用MAC地址，且适配器不使用任何地址，直接向上传递给网络层，利用网络层来判断是否为目的地址。此时主机将被局域网上发送的每个帧而中断，包括被目的地在相同广播局域网上的其他节点的帧中断。

#### 地址解析协议

地址解析协议（Address Resolution Protocol，ARP）用于网络层地址（如IP）与链路层地址（如MAC）的相互转换。

![6-17](https://s2.ax1x.com/2020/02/04/1BBTsK.png)

考虑IP地址222.222.222.220（设为主机a）向主机222.222.222.222（设为主机b）发送IP数据报。两个主机均位于相同的子网中。为了发送数据报，a需要向他的适配器提供目的IP数据报和目的MAC地址。

a使用ARP确定目的主机的MAC地址。在发送主机的ARP模块取在相同局域网中的任意IP作为输入，然后返回响应的MAC地址。

ARP将一个IP地址解析为一个MAC地址。每台主机或路由器在其内存中有一个ARP表（ARP table），这张表包含IP地址到MAC地址的映射关系。

![6-18](https://s2.ax1x.com/2020/02/04/1BWPeI.png)

如上图，该报构成存在三部分，IP地址、对应的MAC地址、一个寿命（TTL）指示从该表删除对应映射的时间。该表不必包含该子网的每台主机和路由器每个表项。

当发送方主机存在到目的方的表项，可以直接使用表项的内容。当不存在对应表项时，发送方用ARP协议来解析这个地址。首先，发送方构造一个称为ARP分组（ARP packet）的特殊分组。一个ARP分组有几个字段，包括发送和接收IP地址和MAC地址。ARP查询和响应分组具有相同的格式。ARP查询分组的目的是询问子网上所有其他主机和路由器（广播），以确定对应于要解析的IP地址的哪个MAC地址。查询ARP能够被子网的所有其它适配器接收到，且每个适配器将该帧中的ARP分组传递给ARP模块。这些ARP模块中的每个检测与自己表中是否存在对应映射。与之匹配的一个给查询主机发送一个带有所希望映射的响应ARP分组。然后查询主机更新其ARP表。

#### 发送数据报到子网以外

![6-19](https://s2.ax1x.com/2020/02/04/1D9F7q.png)

上图展示了将数据发送到子网以往的例子。子网1的网络地址为111.111.111/24，子网2的网络地址为222.222.222/24。假设主机111.111.111.111向主机222.222.222.222发送一个IP数据报。发送主机向其适配器指示一个适当的目的MAC地址。数据报首先要发送到路由器接口111.111.111.110，其是通往最终目的地路径上的第一跳路由器的IP地址。适当的MAC地址是路由器接口111.111.111.110的适配器地址。发送主机通过ARP获取该地址。路由器决定该数据报要被转发的正确接口。通过查找路由器转发表和报文IP地址决定要被转发的接口，将数据报传递给该接口的适配器，适配器将数据封装在一个新的帧中，并将帧发送进子网，此时该帧的目的MAC地址即为目的地MAC地址，同样使用ARP获取该地址。

### 以太网

集线器是一种网络层设备，它作用于各个比特而不是作用于帧。当表示一个0或1的比特到达一个接口时，集线器只是重新生成该比特，其能量强度放大，并将该比特向其他所有接口传输出去。因此基于集线器的星型拓扑的以太网也是一个广播局域网。

#### 以太网帧结构

![6-20](https://s2.ax1x.com/2020/02/04/1Dic8K.png)

考察各个字段：

1. 数据字段（46-1500字节）：承载IP数据报。以太网的最大传输单元（MUT）是1500字节。数据字段的最小长度是46，如果小于46字节，数据报需要填充到46字节。
2. 目的地址（6字节）：目的适配器的MAC地址。
3. 源地址（6字节）：传输该帧到局域网上的适配器的MAC地址。
4. 类型字段（2字节）：类型字段允许以太网复用多种网络层协议。类型字段告诉主机需要将数据报传递给哪个网络层协议。
5. CRC（4字节）：循环冗余检测使得接收适配器检测中是否引入了差错。
6. 前同步码（8字节）：以太网帧以一个8字节的前同步码（Preamble）字段开始。该前同步码的前7字节的值都是10101010；最后一个字节是10101011。前同步码字段的前7字节用于唤醒接收适配器（告诉适配器由数据来了），并且将它们的时钟和发送方的时钟同步。接收适配器只需要锁定前同步码的前七个字节的比特，就能够锁定发送方适配器的时钟。前同步码的第8个字节的最后两个比特（第一个出现的两个连续的1）警告接收适配器，重要的内容就要来了。

以太网技术都向网络层提供无连接服务。以太网技术向网络层提供不可靠服务。

#### 以太网技术

吉比特以太网的标准称为IEEE 802.3z，它完成以下工作：

1. 使用标准以太网帧格式，并且向后兼容10BASE-T与100BASE-T技术，使得吉比特以太网和现已安装的以太网设备基础很容易集成。
2. 允许点对点链路以及共享的广播信道（使用集线器）。吉比特以太网术语中，集线器被称为“带缓存的分配器”。
3. 使用CSMA/CD来共享广播信道。
4. 对于点对点信道，允许在两个方向都以40Gbps全双工操作。

### 链路层交换机

交换机的任务是接收入链路层帧并将它们转发到出链路层。交换机自身对子网中的主机和路由器是透明的，即某主机/路由器向另一个主机/路由器寻址一个帧（而不是向交换机寻址该帧），顺利地将该帧发送进局域网，并不知道交换机将会接收该帧并将它转发到另一个节点。

#### 交换机转发和过滤

过滤（filtering）是决定一个帧应该转发到某个接口还是应该将其丢弃的交换机功能。转发（forwarding）是决定一个帧一个被导向哪个接口，并把该帧移动到那些接口的交换机功能。交换机的过滤和转发功能借助于交换机表（switch table）完成。交换机表中一个表项包括：1）一个MAC地址；2）通向该MAC地址的交换机接口；3）表项放置在表中的时间。

![6-22](https://s2.ax1x.com/2020/02/04/1DVs10.png)

目的地地址为a的帧从交换机接口x到达。交换机使用MAC地址a索引它的表，可能存在三种情况：

1. 表中没有对于a的表项：此时，交换机向除接口x外的所有接口前面的输出缓冲转发该帧的副本。即，如果没有对于目的地的表项，则广播该帧。
2. 表中有一个表项将a与接口x连续起来：此时，该帧从包含适配器a的局域网网段到来（该帧已经在包含目的地的局域网网段广播过了）。无需将该帧转发到任何其他接口，交换机通过丢去该帧执行过滤功能即可。
3. 表中有一个表项将a与接口y（不等于x）联系起来：此时该帧需要被转发到与接口y相连的局域网网段。交换机通过将该帧放到接口y前面的输出缓存来完成转发功能。

#### 自学习

交换机的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预，即交换机是自学习的。这是通过如下方式实现的：

1. 交换机初始表空。
2. 对于在每个接口收到的每个入帧，该交换机在其表中存储：1）在该帧源地址字段中的MAC地址；2）该帧到达的接口；3）当前时间。交换机以这种方式在它的表中记录了发送节点所在的局域网网段。如果局域网上的每个主机最终都发送了一个帧，则每个主机最终将在这张表中留有记录。
3. 如果在一段时间（称为老化期（aging time））后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。以这种方式，如果一台PC被另一台PC代替，原来PC的MAC地址将被从该交换机表中清除掉。

交换机是即插即用设备，其不需要网络管理员或用户的干预。交换机也是双全工的，这意味着任何交换机接口能够同时接收和发送。

#### 链路层交换机的性质

1. 消除碰撞：使用交换机（不使用集线器）构建的网络中，没有因为碰撞而浪费的带宽。交换机缓冲帧并且绝不会在网段上同时传输多个帧。
2. 异质的链路：交换机将链路彼此隔离，因此局域网中的不同链路能够以不同的速度运行并且能够在不同的媒体上运行。
3. 管理：交换机易于进行网络管理。

交换机毒化：其向交换机发送大量具有不同伪造源MAC地址的分组，用伪造表填满交换机表，没有为合法主机留下空间。

#### 交换机与路由器比较

路由器使用网络层地址转发分组的存储转发分组交换机。交换机使用MAC地址转发分组。交换机是第二层的分组交换机，路由器是第三层的分组交换机。

交换机：优点：即插即用；具有相对高的分组过滤和转发速率；缺点：交换机必须处理高至第二层的帧，而路由器必须处理高至第三层的帧；交换机网络的活跃拓扑限制为一颗生成树；大型交换机网络要求主机和路由器有大量的ARP表，这将生成可观的ARP流量和处理量，交换机对于广播风暴并不提供任何保护措施，如果主机处理故障并传输出没完没了的以太网广播帧流，该交换机将转发所有这些帧，使得整个以太网崩溃。

路由器：优点：当网络层中存在冗余路径时，分组通常也不会通过路由器循环，因此分组不会被限制到一颗生成树上，并且可以使用源和目的之间的最佳路径；提供了防火墙保护。缺点：不是即插即用的；路由器处理时间更长。

通常，由几百台主机组成的小网络通常只有几个局域网网段，此时交换机就够了，因为不要求IP地址的任何配置就能使流量局部化并增加总计吞吐量。在由几千台主机组成的更大网络中，通常在网络中除了交换机以外还包含路由器。路由器提供了更健壮的流量隔离方式和对广播风暴的控制，并且在网络的主机之间使用更智能的路由。

### 虚拟局域网

在之前的讨论中，现代机构的的局域网常常是配置为等级结构的，每个工作组有自己的交换局域网，经过一个交换机等级结构与其他工作组的交换局域网互联。这样的结构存在三个缺点：

1. 缺乏流量隔离：尽管该等级结构把组流量局域化到一个单一交换机中，但广播流量任然必须跨越整个网络机构。限制这些广播流量的范围将改善局域网的性能，同时增强安全和隐私性。
2. 交换机的无效使用：如果该机构不止3个组，而是10个组，则将要求有10个第一级交换机。如果每个组比较小，交换机不能提供流量隔离会造成交换机资源浪费。
3. 管理用户：如果一个雇员在不同组间移动，必须改变物理布线以改变该雇员的连接。

这些难题都能通过支持虚拟局域网（Virtual Local Network， VLAN）的交换机来处理。支持VLAN的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。在一个VLAN内的主机彼此通信，仿佛它们与交换机相连。在一个基于端口的VLAN中，交换机的端口由网络管理员换分为组。每个组构成一个VLAN，在每个VLAN中的端口形成一个广播域。下图显示了具有16个端口的单一交换机：

![6-25](https://s2.ax1x.com/2020/02/04/1DzkIf.png)

端口2-8属于电气工程系（EE）VLAN，端口9-15属于计算机科学系（CS）VLAN。这个VLAN解决了上面调到的所有困难，即EE VLAN与CS VLAN帧彼此隔离。网络管理员使用交换机管理软件申明一个端口属于到某个给定的VLAN，在交换机中维护一张端口到VLAN的映射表：交换机软件仅在属于相同VLAN的端口之间交付帧。

EE的流量如何发送到CS呢？解决这个问题的一种方式是将VLAN交换机的一个端口与一台外部的路由器相连，并且将该端口配置为属于EE VLAN和CS VLAN。此时，即使电子工程系和计算机系共享相同的物理交换机，其逻辑看起来也仿佛具有分离的经由路由器连接的交换机。从EE发往CS的数据报将首先跨越EE VLAN到达路由器，然后由该路由器转发跨越CS VLAN到达CS主机。

![6-26](https://s2.ax1x.com/2020/02/04/1rpTMQ.png)

VLAN干线连接（VLAN trunking）：每台交换机上的一个特殊端口被配置为干线端口，以互联这两台VLAN交换机。该干线端口属于所有VLAN，发送到任何VLAN的帧经过干线链路转发到其他交换机。IEEE定义了一种扩展以太网格式——802.1Q，用于跨越VLAN干线的帧，用于交换机确定到达干线的帧属于哪个VLAN。该结构如下图：

![6-27](https://s2.ax1x.com/2020/02/04/1r9VJK.png)

该帧由标准以太网帧与加进首部的4字节VLAN标签组成，VLAN标签承载该帧所属的VLAN标识符。VLAN标签由在VLAN干线发送侧的交换机加进帧，解析后并由VLAN干线接收侧的交换机删除。VLAN标签自身由一个2字节的标签协议标识符字段、一个2字节的标签控制信息字段和一个3比特优先权字段组成。

除了基于端口的VLAN，还有基于MAC的，基于网络层协议和其他准则进行定义。

## 链路虚拟化：网络作为链路层

多协议标签交换（MPLS）是一种分组交换的虚电路网络。

### 多协议标签交换

多协议标签交换（Multiprotocol Label Switching，MPLS）采用虚电路网络的固定长度标签。目标是：对于基于固定长度标签和虚电路的技术，在不放弃基于目的地IP数据报转发的基础设施的前提下，当可能时通过选择性地标识数据报并允许路由器基于固定长度的标签（而不是目的地IP地址）转发数据报来增强其功能。

![6-28](https://s2.ax1x.com/2020/02/05/1ryuex.png)

MPLS使能的路由器处理的链路层帧格式如上图。该帧具有一个MPLS首部，位于第二层首部和第三层首部之间。

上图表面，一个MPLS帧仅能够在两个均为MPLS使能的路由器之间发送。一个MPLS使能的路由器被称为标签交换路由器，因为它通过在其转发表中查找MPLS标签，然后立即将数据报传递给适当的输出接口来转发MPLS帧。MPLS使能的路由器不需要提取目的IP地址和在转发表中执行最长前缀匹配的查找。

![6-29](https://s2.ax1x.com/2020/02/05/1rcKPO.png)

如上图，R1到R4都是MPLS使能的，R5和R6是标准的IP路由器。MPLS提供了沿着多条路由转发分组的能力。

## 数据中心网络

 大型因特网公司构建了大量的数据中心，每个数据中心都有自己的数据中心网络（data center network），数据中心网络将其内部主机彼此互联并与因特网的数据中心互联。

主机负责提供内容（如网页和视频），存储邮件和文档，并共同执行大规模分布式计算。数据中心的主机称为刀片，一般是包括CPU、内存和磁盘存储的商用主机。主机被堆叠在机架上，每一个机架顶部有一台交换机，称为机架顶部（Top of Rack，TOR）交换机，它们与机架上的主机互联，并与数据中心的其他交换机互联。机架上每台主机都有一块与TOR交换机连接的网卡，每台TOR交换机有额外的端口能够与其他TOR交换机连接。每台主机也会分配一个自己的数据中心内部的IP地址。

数据中心支持两种类型的流量：外部客户与内部主机之间流动的流量，以及内部主机之间流动的流量。为了处理外部客户与内部之间流动的流量，数据中心网络包含一台或多台边界路由器，它们将数据中心网络与公共因特网相连。数据中心网络因此需要将所有机架彼此互联，并将机架与边界路由器相连。如下图显示了一个数据中心的例子：

![6-30](https://s2.ax1x.com/2020/02/05/1sQQQH.png)

### 负载均衡

在数据中心内部，外部请求首先被定向到负载均衡器（load balancer）。负载均衡器的任务是向主机分发请求，以主机当前的负载作为函数来在主机之间均衡负载。一个大型的数据中心通常会有几台负载均衡器，每台服务于一组特定的云应用。负载均衡器基于分组的目的端口号（第四层）以及目的IP地址做决策，因此其被称为“第四层交换机”。一但接收到一个对于特定应用程序的请求，负载均衡器将该请求分发大处理该应用的某一台主机（该主机可能再次调用其他主机来协助处理）。当主机处理完该请求后，向负载均衡器回送响应，再由负载均衡器返回给客户。负载均衡器不仅平衡主机间的工作负载，还提供类似NAT的功能，这防止客户直接接触主机，从而具有隐蔽网络内部结构和防止客户直接交互等安全性。

### 等级体系结构

大型数据中心通常应用路由器和交换机等级结构（hierarchy of router and switch），即为上图结构。该结构顶端，边界路由器与接入路由器相连（接入路由器可以有更多）。在每台接入路由器下面，有3层交换机。每台接入路由器与一台第一层交换机相连，每台第一层交换机与多台第二层交换机以及一台负载均衡器相连。每台第二层交换机又通过机架的TOR交换机（第三层交换机）与多个机架相连。所有链路通常使用以太网作为链路层和网络层协议，并混合使用铜缆和光缆。

云应用提供商持续提供高可用性的应用是至关重要的，所以数据中心在他们的设计中也包含冗余网络设备和冗余链路。如，每台TOR能够与两台第二层交换机相连，每台接入路由器、第一层交换机和第二层交换机可以冗余并集成到设计中。上图中，每台接入路由器下的这些主机构成了单一子网，为使ARP广播流量本地化，这些子网的每个都被进一步划分为更小的VLAN子网。

上述的传统等级系统结构解决了扩展性问题，但存在主机到主机容量受限的问题。

### 数据中心网络的发展趋势

数据中心网络一个趋势是部署能够克服传统等级设计缺陷的新型互联网体系结构和网络协议。一种方法是采用全连接拓扑来替代交换机和路由器的等级结构，下图展示了这种拓扑：

![6-31](https://s2.ax1x.com/2020/02/05/1sydaV.png)

该结构中，每台第一层交换机都与所有第二层交换机相连。因此：1）主机到主机的流量绝不会超过该交换机层次。2）对于n台第一层交换机，在任意两台二层交换机有n个不相交的路径。这是设计可以显著地改善主机到主机的容量。

另外一个主要趋势就是采用基于船运集装箱的模块化数据中心（Modular Data Center，MDC）。

## Web页面请求的历程

Bob使用便携机与学校的因特网相连，下载一个Web页面。其网络如图：

![6-32](https://s2.ax1x.com/2020/02/06/1yfnv8.png)

### 准备：DHCP、UDP、IP和以太网

请求一个分配一个IP地址。

1. Bob操作系统生成一个DHCP请求报文，将这个报文放入具有目的端口67和源端口68的UDP报文段。该报文被放置在具有广播IP地址255.255.255.255和源地址0.0.0.0的IP数据报中。
2. 包含DHCP请求报文的IP数据报被放置在以太网帧中。该以太网帧目的地址为FF.FF.FF.FF.FF.FF，该帧源MAC地址是Bob机器的MAC地址。
3. 包含DHCP请求的广播以太网帧是第一个由Bob便携机发送到以太网交换机非帧。该交换机的出端口广播入帧，包括连接到路由器的端口。
4. DHCP请求报文被分解到达UDP，DHCP服务器获取该请求。
5. 假设DHCP服务器能够以CIDR块68.85.2.0/24分配IP地址。DHCP服务器生成包含分配给便携机的IP地址以及DNS服务器的IP地址（68.85.71.266）、默认网关路由器IP地址（68.85.2.1）和子网块（68.85.2.0/24）的一个DHCP ACK报文。该报文被放入一个UDP报文中，UDP报文被放入一个IP数据报中，IP数据报被放入一个因特网帧中。
6. 包含DHCP ACK的以太网帧由路由器发送给交换机。由于交换机是自学习的，所以交换机能够寻址到便携机的MAC地址，并仅从通向其地址的输出端口转发。
7. Bob便携机接收到包含DHCP ACK的以太网帧，从该帧中提前IP数据报，IP数据报抽取UDP报文，UDP报文抽取DHCP ACK报文。Bob的DHCP客户记录下它的IP地址和它的DNS服务器的IP地址，还在其IP转发表中安装默认网关的地址。Bob便携机将向该默认网关发送目的地址为其子网68.85.2.0/24以外的所有数据报。

### 仍在准备：DNS和ARP

请求google的DNS。

8. Bob便携机操作系统生成一个DNS查询报文，将www.google.com放入DNS报文的问题段中。该DNS报文放置在53号目的端口的UDP报文段。该UDP报文段则被放入具有IP目的地址68.87.71.226和源地址68.85.2.101的IP数据报。
9. Bob便携机将包含DNS请求的数据报放入一个以太网帧中，该帧发往Bob学校的网关路由器。然而其不知道网关路由器的MAC地址需要使用ARP协议获取该地址。
10. 便携机输出一个具有IP地址68.85.2.1的ARP查询报文，将该报文放置到一个具有广播目的地址的因特网帧中，并向交换机发送该以太网帧。
11. 网关路由器获取查询报文，并准备一个ARP回答，向交换机发送该回答。
12. Bob便携机接收ARP回答，获取网关ARP的MAC地址。
13. Bob便携机能够使包含DNS查询的以太网帧寻址到网关路由器的MAC地址。

### 仍在准备：域内路由选择到DNS服务器

获取DNS回答

14. 网关路由器接收该帧并抽取DNS查询的IP数据报。路由器查找该数据报的目的地址，并根据其转发表决定该数据报应该发送到图6-32的Comcast网络中最左边的路由器。
15. 在Comcast网络中最左边的路由器收到该帧，抽取IP数据报，检查该数据报的目的地址，并根据其转发表确定出接口，经过该接口朝DNS服务器转发数据报转发表根据Comcast域内协议和BGP填写。
16. DNS查询的IP数据报到达DNS服务器。其在DNS数据库中查找名字www.google.com，找到包含对于的IP地址的DNS源记录。该DNS服务器形成一个包含主机名到IP地址映射的DNS回答报文。报文经封装，经以太网交换机到Bob便携机。
17. Bob便携机从DNS获取谷歌的IP地址。

### Web客户-服务器交互：TCP和HTTP

18. Bob便携机生成TCP套接字，用于发送HTTP GET报文。生成TCP套接字，首先与服务器进行三次握手。便携机首先生成一个目的端口80的TCP SYN报文段。
19. 该报文向谷歌转发。
20. TCP SYN到达谷歌。谷歌生成一个TCP SYNACK报文段，向便携机发送。
21. 便携机收到TCP SYNACK报文，进入连接状态。
22. 便携机向谷歌发送HTTP GET报文。
23. 谷歌获取HTTP GET报文，生成响应，发送会Bob。
24. Bob获取报文，显示内容。

# 第七章 无线网络和移动网络

## 概述

![7-1](https://s2.ax1x.com/2020/02/09/1fBbKU.png)

无线体系结构包含下列要素：

1. 无线主机：主机是运行应用程序的端系统设备。

2. 无线链路：主机通过无线通信链路（wireless communication link）连接到一个基站或者另一台无线主机。下图展示了不同的无线链路计数：

   ![7-2](https://s2.ax1x.com/2020/02/09/1fyFqU.png)

   无线链路将位于网络边缘的主机连接到更大的网络基础设施中。

3. 基站：负责向与之关联的无线主机发送和接收数据。一台主机与一个基站相关连指：1）该主机位于该基站的无线通信覆盖范围内；2）该主机使用该基站中继它和更大网络之间的数据。蜂窝塔和无线LAN的接入点都是属于基站。基站与更大网络连接。与基站关联的主机称为以基础设施模式运行。

4. 网络基础设施：无线主机希望与之进行通信的更大的网络。

依据两个准则对无线网络分类：1）在该无线网络中的分组是否跨越一个无线跳或多个无线跳；2）网络中是否有诸如基站的基础设施。

1. 单挑，基于基础设施：这些网络有与较大的有线网络相连的基站，该基站与无线主机之间的所有通信都经过一个无限跳。
2. 单跳，无基础设施。
3. 多跳，基于基础设施。
4. 多跳，无基础设施。

## 无线链路和网络特征

有线链路和无线链路的区别：

1. 递减的信号强度：无线信号强调随着发送方与接收方距离的增加而减弱。（路径损耗）
2. 来自其他源的干扰：在同一频段发送信号的电磁波将相互干扰。
3. 多径传播：当电磁波的一部分受物体和地面反射，在发送方和接收方之间走了不同路径，会出现多径传播。使得接收方收到的信号变得模糊。

上述讨论表面，无线链路的比特差错比有线中的更多。因此无线协议不仅使用CRC错误检测，还采用链路层ARQ协议来重传受损的帧。

对于接收无线信号的主机来说，信噪比（Signal-to-Noise Ratio，SNR）是所收到的信号和噪声强度的相对测量（比值）。单位为分贝dB。

隐藏终端问题：如下图，A和C所处的位置使他们信号强度的衰减不足以使它们相互检测到对方的传输，然而它们的传输足以强到在B处相互干扰。

![7-4](https://s2.ax1x.com/2020/02/09/1fhUrn.png)

### CDMA

当不同主机使用一个共享媒体通信时，需要有一个协议来保证多个发送方发送的信号不在接收方相互干扰。码分多址（Code Division Multiple Access，CDMA）属于信道划分协议族。

CDMA中，要发送的每个比特都通过乘以一个信号（编码）的比特来进行编码，这个信号的变化速率（码片速率）比初始数据比特序列的变化速率快得多。下图展示了一个简单的CDMA编码/解码情形。为了方便，具有0值的数据比特表示为-1。

![7-5](https://s2.ax1x.com/2020/02/09/1hKglq.png)

CDMA的工作有一种假设，即对干扰的传输比特信号是加性的。如果仔细选择发送方的编码，每个接收方能够通过各自的解码公式来恢复各自的数据。如下图：

![7-6](https://s2.ax1x.com/2020/02/09/1hM7VS.png)

## WiFi: 802.11无线LAN

IEEE 802.11协议族使用相同的媒体访问协议CSMA/CA。链路层帧也使用相同的帧结构，且802.11产品是向后兼容的。

### 802.11体系结构

![7-7](https://s2.ax1x.com/2020/02/10/14FBp8.png)

802.11体系结构基本模块是基本服务集（Basic Service Set，BSS）。一个BSS包含一个或多个无线站点和一个在术语中称为接入点（Access Point，AP）的中央基站（Base station）。上图7-7展示了一个基本结构。

每个802.11无线站点（主机）都具有一个6字节的MAC地址，改地址存储在该站适配器（网络接口卡）的固件中。每个AP的无线接口也具有一个MAC地址。

配置AP的无线LAN被称作基础设施无线LAN（infrastructure wireless LAN），基础设施是指AP联通互联AP和一台路由器的有线以太网。上图7-8展示了站点也能自己组合形成一个自组织网络。

#### 信道与关联

802.11中每个无线站点在能够发送或者接收网络层数据之前，必须与一个AP相关联。

管理员安装一个AP时，为该接入点分配一个单字或双字的服务集标识符（Service Set Identifier，SSID）（即WiFi名字）。管理员还需要为该AP分配一个信道号。

WiFi丛林（WiFi jungle）是一个任意物理位置，在这里无线站点能够从两个或多个AP中收到很强的信号。为了让无线站点知道哪个AP位于该丛林中，802.11标准要求每个AP周期性地发送信标帧，每个信标帧包括该AP的SSID和MAC地址。无线站点为了获取AP，需要进行扫描。通过信标帧了解到可用AP后，选择一个AP用于关联。

扫描信道和监听信标帧的过程被称为被动扫描。无线主机也可以执行主动扫描，这是通过向位于无线主机范围内的所有AP广播帧完成的。如下图：

![7-9](https://s2.ax1x.com/2020/02/10/14EONn.png)

一旦与一个AP关联，主机希望加入该AP所属的子网中。因此该主机通常将通过关联的AP向该子网发送一个DHCP发现报文以获取在该AP子网中的一个IP地址。获取后，网络其他部分将直接视你的主机为该子网中的另一台主机。

### 802.11 MAC协议

802.11的多路访问协议为带碰撞避免的CSMA（CSMA with collison avoidance）简写为CSMA/CA。CSMA表示载波监听多路访问。802.11未实现碰撞检测是因为：

1. 检测碰撞要求站点同时能够发送和接受的能力。802.11适配器上，接收信号的强度远远小于发送信号强度，制造响应检测硬件成本太大。
2. 即使适配器可以同时发送和监听信号，也会由于隐藏终端问题无法检测到所有碰撞。

802.11 MAC使用链路层确认。如下图，目的站点收到一个通过CRC校验的帧后，等待一个被称为短帧间间隔（Short Inter-Frame Spacing，SIFS）的一小段时间，然后发回确认帧。如果发送站点在给定时间未收到确认帧，即假定错误并重传。

![7-10](https://s2.ax1x.com/2020/02/10/14XkPH.png)

CSMA/CA协议：

1. 如果某站点最初监听到信道空闲，将在一个被称为分布式帧间间隔（Distributed Inter-Frame Space，DIFS）的段时间段后发送该帧。
2. 否则，该站选择一个随机回退值并且在侦听信道空闲时递减该值。当侦听到信道忙时，计数值保持不变。
3. 当计数值减到0时，该站点发送整个数据帧并等待确认。
4. 如果收到确认，即确定帧被正常接收。如果该站点还要发送帧，从第二步开始协议。如果未收到确认，发送站点重新进入第二步中的回退阶段，并从一个更大的范围内选取随机值。

#### 处理隐藏终端：RTS和CTS

为了解决隐藏终端问题802.11协议允许站点使用一个段请求发送报文（Request to Send，RTS）控制帧和一个短允许发送（Clear to Send，CTS）控制帧来预约对信道的访问。当发送方要发送一个DATA帧时，首先向AP发送一个RTS帧，指示传输DATA帧和确认（ACK）帧所需要的总时间。当AP收到RTS后，广播一个CTS帧作为响应。CTS帧有两个目的：给发送方明确的发送许可，也指示其他站点在预约期内不要发送。如下图：

![7-12](https://s2.ax1x.com/2020/02/10/14xGzd.png)

实际中，每个站点可以设置一个RTS门限值，仅当帧长度超过门限值时，才使用RTS/CTS序列。对于无线站点而言，默认的RTS门限值大于最大帧长度，因此对于所以发送的DATA帧，RTS/CTS被跳过。

### IEEE 802.11 帧

![7-13](https://s2.ax1x.com/2020/02/10/14zOjs.png)

#### 有效载荷与CRC字段

帧核心是有效载荷，常由一个IP数据报或者ARP分组组成。还包括一个循环冗余校验（CRC）。

#### 地址字段

4个地址字段，每个都包括一个6字节的MAC地址。其中包括一个源地址，一个目的地址。当AP在自组织模式中互相转发时使用第四个地址。这里我们只考虑前三个地址：

1. 地址2是传输该帧的站点MAC地址。如果一个无线站点传输该帧，该站的MAC地址就被插在地址2字段。如果一个AP传输该帧，该AP的MAC地址被插入在地址2字段。
2. 地址1是接收该帧的无线站点的MAC地址。
3. BBS（由AP和无线站点组成）是一个子网的一部分，并且这个子网经过一些路由器接口与其他子网相连。地址3包含这个路由器的MAC地址。

为了理解地址3，考虑下图的网络：

![7-14](https://s2.ax1x.com/2020/02/10/159U1g.png)

应当记住，AP是一个链路层设备，不能够立即IP。考虑从路由器接口R1到无线站点H1之间传输一个报文。路由器并不清楚在H1和其自身之间存在一个AP，从路由器的观点来说，H1仅仅是路由器所连接的子网终端一台主机。

1. 路由器知道H1的IP地址，它使用ARP获取H1的MAC地址。路由器接口R1将数据封装在以太网帧中。源地址为R1的MAC地址，目的地址为H1的MAC地址。
2. 当该帧到达AP后，AP传输出去之前，先将以太网帧转换为802.11帧。AP将地址1和地址2分别填上H1的MAC地址和其自身的MAC地址。地址3，AP插入R1的地址。这样H1可以确定将数据报发送到子网中的路由器接口的MAC地址。

考虑H1移动一个数据报的R1的过程：

1. H1生成一个802.11帧，分别用AP的MAC地址和H1的MAC地址填充地址1和地址2字段。对于地址3，H1插入R1的MAC地址。
2. 当AP接收到802.11帧后，将其转换为以太网帧。该帧的地址字段是H1的MAC地址，目的地址是R1的MAC地址。地址3允许AP在构建以太网帧时能够确定目的MAC地址。

#### 序号、持续期和帧控制字段

如运输层TCP协议一样，序号可以使接收方区分重新传输的帧和以前帧的重传。

802.11协议允许传输节点预约信道一段时间，包括传输帧时间和确定时间。这个时间被包括在持续期字段中。

帧控制字段中类型和子类型字段用于区分关联、RTS、CTS、ACK和数据帧。To和From字段用于定义不同地址字段含义。WEP字段指示是否使用加密。

### 在相同的IP子网中的移动性

在同一个子网的不同BBS之间移动较为简单。即根据信号强度选择不同的AP，不会重新分配IP地址，能够简单的维持TCP连接（借助于链路层的自学习）。

### 802.11中的高级特色

#### 802.11速率适应

802.11实现具有一种速率自适应能力，可以根据当前和近期信道特定来选择物理层调制技术。具体方式与TCP拥塞控制类似。

#### 功率管理

一个节点能够明显地在睡眠和唤醒之间交替。

### 个人域网络：蓝牙和ZigBee

#### 蓝牙

IEEE 802.15.1网络以低功率和低成本在小范围内运行。本质是一个低功率、小范围、低速率的电缆替代技术。802.15.1网络有时被称为无线个人域网络（Wireless Persional Area Network，WPAN）。802.15.1网络以TDM方式工作于无需许可证的2.4GHz无线波段。在每个时隙内，发送方利用79个信道的一个进行传输，同时从时隙到时隙以一个已知的伪随机方式变更信道。

802.15.1网络是自组织网络：不需要网络基础设施（如一个接入点）来互联802.15.1设备。

## 蜂窝因特网接入

### 蜂窝网体系结构概述

本节使用全球移动通信系统（GSM）标准术语。

#### 2G蜂窝网络体系结构：语音与电话网连接

术语蜂窝（cellular）指这样一个事实：即由一个蜂窝网覆盖的区域被分成许多称为小区（cell）的地理覆盖区域。小区如下图左侧所示。每个小区包含一个收发基站（Base Transceiver Sattaion，BTS），负责向位于其小区内的移动站点发送和接收信号。

![7-18](https://s2.ax1x.com/2020/02/10/154tgO.png)

2G蜂窝系统的GSM标准对空中接口使用了组合FDM/TDM（无线电）。如果信道被划分为F个子带，并且时间被划分为T个时隙，那么该信道能够支持F*T个并发的呼叫。

一个GSM网络的基站控制器（Base Station Controller，BSC）通常服务于几十个收发基站。BSC的责任是为移动用户分配BTS无线信道，执行寻呼（paging）（找到移动用户所在小区），执行移动用户的切换。基站控制器及其控制的收发基站共同构成了GSM基站系统（Base Station System，BSS）。

用于鉴别和账户管理以及呼叫建立和切换中，移动交换中心（Moblie sWitching Center，MSC）起着决定性作用。

### 3G蜂窝数据网：将因特网扩展到蜂窝用户

![7-19](https://s2.ax1x.com/2020/02/10/15IdAA.png)

#### 3G核心网

3G核心蜂窝数据网将无线电话入网连接到公共因特网。3G核心网中有两类结点：服务通用分组无线服务支持节点（Serving Generalozed packet radio service Support Node，SGSN）和网关GPRS支持节点（Gateway GPRS Support Node，CGSN）。一个SGSN负责向位于其连接的无线电接入网点中的移动节点交付数据报。

#### 3G无线电接入网：无线边缘

3G无线电接入网（radio access network）是作为3G用户看到的无线第一跳网络。无线电网络控制器（Radio Network Controller，RNC）通常控制几个小区的收发基站。RNC既通过MSC与电路交换蜂窝语音网连接，又通过SGSN与分组交换的因特网连接。

3G不再使用GSM的FDMA/TDMA方案，在TDMA时隙中使用称为直接序列宽带CDMA（Direct Sequence Wideband CDMA，DS-WCDMA）。TDMA时隙又可在多个频率上可供使用。

## 移动管理：原理

在一个网络环境中，一个移动节点的永久居所被称为归属网络（home network），在归属网络中代表移动节点执行下面讨论的移动管理功能的实体叫归属代理（home agent）。移动节点当前所在网络叫做外部网络（foreign network）或被访网络（visited network），在外部网络中帮助移动节点做移动管理功能的实体称为外部代理（foreign agent）。如下图：

![7-23](https://s2.ax1x.com/2020/02/10/15LPDf.png)

### 寻址

为了使用户移动性对网络应用透明，希望一个移动节点在从一个网络移动到另一个网络时保持其地址不变。当某移动节点位于一个外部网络时，所有指向此节点固定地址的流量需要导向外部网络。

外部代理的作用之一是为移动节点创建一个所谓的转交地址（Care-of Address，COA），该COA的网络部分与外部网络的网络部分相匹配。因此一个移动节点可与两个地址关联，即其永久地址与其COA，该COA有时又称为外部地址。上图中，移动节点的固定地址是128.119.4.186，COA为79.129.13.2。外部代理的第二个作用就是告诉归属代理，该移动节点在它的网络中具有给定的COA。该COA将用于将数据报通过外部代理重新路由选择来转移节点。

### 路由选择到移动节点

#### 移动节点的间接路由选择

在间接路由选择（indirect routing）方法中，通信者只是将数据报寻址到移动节点的固定地址，并将数据报发到网络中去，完全不知道移动节点是归属网络还是正在访问某个外部网络，因此移动性对于通信者来说是完全透明的。如下图：

![7-24](https://s2.ax1x.com/2020/02/11/1oQxyj.png)

归属代理除了负责与外部代理交互以跟踪移动节点的COA外，还要监视到达的数据报，这些数据报寻址的节点的归属网络与该归属代理所在网络相同，但这些节点当前却在某个外部网络中。归属代理截获这些数据报，然后按一个两步骤的过程转发给它们。（上图的2和3）。

归属代理将通信者的原始完整1数据报封装在一个新的更大的数据报中，这个较大的数据报被导向并交付到移动节点的COA。COA接收并拆封该数据报，取出原始数据，在将数据交付移动节点。这里封装/拆封与隧道概念一致。下图展示了该过程：

![7-25](https://s2.ax1x.com/2020/02/11/1o1frd.png)

对于移动节点向通信者发送数据报，可以直接将数据寻址到通信者。

间接路由选择内容：

1. 移动节点到外部代理的协议：当移动节点连接到外部网络时，它向外部代理注册，类似的，当一个移动节点离开该外部网络时，向外部代理取消注册。
2. 外部代理到归属代理的注册协议：外部代理将向归属代理注册移动节点的COA。移动节点离开其网络时，外部代理不需要显示注销COA，因为当移动节点移动到一个新网络时，随之就要注册一个新的COA，同时将完成注销。
3. 归属代理数据报封装协议：将通信者的原始数据报封装在一个目的地址为COA的数据报之内，并转发。
4. 外部代理拆封协议：从封装好的数据报中取出原始数据，转发给移动节点。

#### 移动节点的直接路由选择

间接路由选择存在一个低效问题，即三角路由选择问题，即发送到移动节点的数据报也要先发给归属代理，然后再发送到外部网络。

直接路由选择（direct routing）克服了三角路由选择的低效问题(直接使用隧道到COA)，但却以增加复杂性为代价的。具体原理如下图：

![7-26](https://s2.ax1x.com/2020/02/11/1oJvlT.png)

直接路由选择引入两个新问题：

1. 需要一个移动用户定位协议（mobile-user location protocol），以便通信者代理向归属代理查询获得移动节点的COA（上图中的步骤1和2）。
2. 当移动节点从一个外部网络移动到另一个外部网络时，如何将数据报发到新的外部网络。间接选路可以通过更新由归属代理维护的COA来解决，直接选路中，归属代理仅在会话开始时被通信者代理询问一次COA。必要时在归属代理中更新COA，不足以解决该问题。

对于第二个问题。一种解决方案是创建一个新的协议来告知通信者变化后的COA。另一种方案是GSM网络实践中采用的方案，工作方式为：假设数据当前正转发给位于某个外部网络中的移动节点，并且在会话刚开始时该移动节点就位于该网络中（下图步骤1）。将首次发现移动节点的外部网络中的外部代理标识为锚外部代理（anchor foreign agent）。当移动节点到达一个新外部网络后（下图步骤2），移动节点向新的外部代理注册（下图步骤3），并且新外部代理向锚外部代理提供移动节点的新COA（下图步骤4）。当锚代理收到一个发往已经离开的移动节点的封装数据报后，它可以使用新的COA重新封装数据报并将其转发给该移动节点（下图步骤5）。如果移动节点其后又移动到另一个外部网络中，在该被访网络中的外部代理随后将与锚外部代理连续，以便建立到该新外部网络的转发。

![7-27](https://s2.ax1x.com/2020/02/11/1oN70e.png)

## 移动IP

支持移动性的因特网通信结构与协议合起来称为移动IP。移动IP标准由三部分组成：

1. 代理发现：移动IP定义了一个归属代理或外部代理用来向移动节点通告其服务的协议，以及移动节点请求一个外部代理或归属代理的服务所使用的协议。
2. 向归属代理注册：移动IP定义了移动节点和/或外部代理向一个移动节点的归属代理注册或注销COA所使用的协议。
3. 数据报的间接路由选择：该标准定义了数据报被一个归属代理转发给移动节点的方式，包括转发数据报使用的规则、处理差错情况和几种不同的封装形式。

### 代理发现

到达一个新网络的某移动IP节点，必须知道相应的外部代理或归属代理的身份。通过一个新的网络地址，才使移动节点中的网络层知道它已进入一个新的外部网络。该过程为代理发现。可以通过两种方式实现：代理通告或代理请求。

借助于代理通告，外部代理或归属代理使用一种现有路由器发现协议的扩展协议来通告其服务。该代理周期性地在所有连接的链路上广播一个类型字段为9（路由器发现）的ICMP报文。路由器发现报文也包含路由器（即该代理）的IP地址。路由器发现报文还包括一个移动性代理通告扩展，其中包含了该移动节点所需的附加信息。存在下列重要字段：

1. 归属代理比特（H）：指出该代理是它所在网络的归属代理。
2. 外部代理比特（F）：指出该代理是它所在网络的一个外部代理。
3. 注册要求比特（R）：指出在该网络中的某个移动用户必须向某个外部代理注册。特定的，一个移动用户不能在外部网络（如使用DHCP）中获得一个转交地址，并假定由它自己承担外部代理的功能，无线向外部代理注册。
4. M、G封装比特：指出除IP-in-IP封装外，是否还要用其他封装形式。
5. 转交地址（COA）字段：由外部代理通过的一个或多个转交地址的列表。移动用户在向其归属代理注册时选择这些地址中的一个作为其COA。

![7-28](https://s2.ax1x.com/2020/02/11/1o0UxI.png)

使用代理请求，一个想知道的移动节点不必等待接收代理通告，就能广播一个代理请求报文，该报文只是一个类型值为10的ICMP报文。收到该请求的代理直接向该移动节点单播一个代理通告，于是该节点将继续处理，就像该受到一个未经请求的通告一样。

### 向归属代理注册

一旦某个移动IP节点收到一个COA，该地址必须向归属代理注册。这通过外部代理或直接通告IP节点自己完成。这里考虑前一种情况：

1. 当收到一个外部代理通告后，一个移动节点立即向外部代理发送一个移动IP注册报文。注册报文承载在一个UDP数据报中并通过端口434发送。注册报文携带以下内容：一个由外部代理通告的COA、归属代理地址（HA）、移动节点的永久地址（MA）、请求的注册寿命和一个64比特的注册标识。注册标识是一个序号，用于收到的注册回答与注册请求的匹配。
2. 外部代理收到注册报文并记录移动节点的永久IP地址。外部代理知道应该查找这样的数据报，即它封装的数据报的目的地址与该移动节点的永久地址匹配。外部代理然后向归属代理的434端口发送一个移动IP注册报文。这一报文包括COA、HA、MA、封装格式要求、请求的注册寿命以及注册标识。
3. 归属代理接收注册请求并检查真实性和正确性。归属代理把移动节点的永久IP地址与COA绑定。以后发送给该代理的数据报与发往移动节点的数据报将被封装并以隧道方式给COA。归属代理发送一个移动IP注册回答，该响应报文中包含HA、MA、实际注册寿命和被认可的请求报文注册标识。
4. 外部代理接收注册响应，然后将其转发给移动节点。

![7-29](https://s2.ax1x.com/2020/02/11/1TF3nS.png)

## 管理蜂窝网中的移动性

与移动IP类似，GSM采用一种间接路由选择方法。移动用户的归属网络被称为该移动用户的归属公共地域移动网络（home Public Land Mobile Network，home PLMN）。简称为归属网络。移动用户向某个蜂窝网提供商订购了服务，该蜂窝网就成为该用户的归属网络。被访问的PLMN，称为被访网络（visited network），是移动用户当前所在网络。归属网络和被访网络的职责：

1. 归属网络维护一个称作归属位置注册器（Home Location Register，HLR）的数据库，其中包括它每个用户的永久蜂窝电话号码以及用户个人概要信息。HLR也包括这些用户当前的位置信息。即，如果一个移动用户当前漫游到另一个提供商的蜂窝网络中，HLR中将包含足够多的信息来获取被访问网络中对该移动用户的呼叫一个路由选择到的地址。当一个呼叫定位到一个移动用户后，通信者将与归属网络中一个称作网关移动服务交换中心（Gateway Mobile service Switching Center。 GMSC）的特殊交换机联系。这里我们称呼GMSC为归属MSC（home MSC）。
2. 被访网络维护一个称作访问者位置注册（Visitor Location Register，VLR）的数据库。VLR为每个当前在其服务网络中的移动用户包含一个表项，VLR随着移动用户进入和离开网络而出现或消失。VLR通常与移动交换中心（MSC）在一起，该中心协调到达或离开被访网络的呼叫建立。

### 对移动用户呼叫的路由选择

一个呼叫定位到被访网络中的一个移动GSM用户的步骤：

![7-30](https://s2.ax1x.com/2020/02/11/1TumtO.png)

1. 通信者拨打移动用户的电话号码，号码中的前几位数字足以全局地判断移动用户的归属网络。呼叫从通信者通过公共交换电话网到达移动用户归属网络中的归属MSC。
2. 归属MSC收到呼叫并查询HLR来确定移动用户的位置。最简单的情况下，HLR返回移动站点漫游号码（MSRN）。这个号码与移动用户的永久电话号码不同，后者与移动用户的归属网络相关联，而漫游号码是短暂的：当移动用户进入一个被访网络后，会给移动用户临时分配一个漫游号码。漫游号码相当于移动IP中转交地址的作用。并且，与COA类似，它是对通信者和移动用户不可见的。如果HLR不具有该漫游号码，它返回被访问网络中的VLR地址。这时，归属MSC需要查询VLR以便获取该移动节点的漫游号码。
3. 给定一个漫游号码，归属MSC提供网络到达被访网络的MSC建立呼叫的第二步。呼叫完成，从通信者到达归属MSC，再次归属MSC到达被访MSC，然后到达为移动用户提供服务的基站。

第二步中，HLR获取有关移动用户位置信息方式是：当一个移动电话切换或进入一个由新的VLR所覆盖的被访问网络后，移动用户向被访网络注册，通过移动用户和VLR之间交换信令报文来实现。被访问VLR随后又向移动用户的HLR发送一个位置更新请求报文。这一报文告知HLR可以用来联系移动用户的漫游号码或者VLR地址。

### GSM中的切换

在一个呼叫过程中，移动站点将其关联从一个基站改变到另一个基站时出现切换。

切换的原因包括：1）当前基站和移动用户之间的信号减弱，使得该呼叫有被中断的风险；2）一个蜂窝处理的呼叫太多，变得过载，通过将一些用户切换到邻近不太拥塞的蜂窝中。

在与一个基站关联期间，移动用户周期性地测量来自其当前基站和邻近它的可以听得到的基站的信标信号强度。这些测量以每秒1-2次的频率报告给移动用户的当前基站。根据这些测量值、邻近蜂窝的移动用户的当前负载以及其他因素，GSM中的切换由旧的基站发起。下图展示了具体步骤：

![7-32](https://s2.ax1x.com/2020/02/11/1TylFK.png)

1. 旧基站（BS）通知被访问MSC即将要进行一个切换，通知移动用户将要切换到的BS。
2. 被访问MSC发送建立到新BS的路径，分配承载重路由选择的呼叫所需的资源，已经用信令告知新BS一个切换即将出现。
3. 新BS分配并激活一个无线信道供移动用户使用。
4. 新BS发出信令返回被访问MSC和就BS，即已经建立了被访问MSC到新BS的路径并且用到用户应当被告知即将发生的切换。新BS提供移动用户与新的BS相关联所需要的所有信息。
5. 移动用户被告知它应当进行一个切换。到目前，移动用户完全不知道网络已经做好了为切换做好的准备工作。
6. 移动用户向新BS交换一个或多个报文，以完全激活新BS中的信道。
7. 移动用户向新BS发送一个切换完成报文，该报文随后向上转发给被访问MSC。MSC重路由选择到移动用户的正在进行的呼叫，使其经过新BS。
8. 沿着到旧BS的路径分配的资源随后被释放。

上面考虑了在同一个MSC之间的不同基站中进行切换。现在考虑在不同MSC之间切换。GSM定义了锚MSC（anchor MSC）的概念。锚MSC是呼叫首次开始时移动用户所访问的MSC，因此在整个呼叫中保持不变。在整个呼叫持续期间，不论移动用户进行了多少次MSC间转换，呼叫总是从归属MSC路由选择到锚MSC，然后再到移动用户当前所在的被访问MSC。当移动用户从一个MSC覆盖区到达另一个MSC覆盖区后，正在进行的呼叫被重路由选择，从锚MSC到包含新基站的新被访问MSC。因此，任何情况下，通信者和移动用户之间至多有3个MSC（归属MSC，锚MSC以及被访问MSC）。如下图：

![7-33](https://s2.ax1x.com/2020/02/11/1Tccaq.png)

另一种方法不用维持从锚MSC到当前MSC的单一MSC跳，将直接链接移动用户访问的MSC。每当移动用户移到一个新的MSC后，让旧的MSC将正在进行的呼叫转发给新MSC。

下表比较了移动IP和GSM：

![7-34](https://s2.ax1x.com/2020/02/11/1Tccaq.png)

## 
